<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Bookshelf Navigation</title>
    
    <!-- Three.js æ ¸å¿ƒåº“ -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    
    <!-- å­—ä½“å›¾æ ‡åº“ï¼ˆå¦‚æœè¿˜æ²¡æœ‰çš„è¯ï¼‰ -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    
    <style>
    /* åŸæœ‰æ ·å¼ä¿æŒä¸å˜ */
    /* æ§åˆ¶æŒ‰é’®å®¹å™¨ - é€‚é…ç§»åŠ¨ç«¯ */
    #controlsContainer {
        position: fixed;
        top: 2vw;
        right: 2vw;
        z-index: 1000;
        background: transparent;
        border: none;
        box-shadow: none;
        backdrop-filter: none;
        padding: 1vw;
        min-width: auto;
    }

    /* æ§åˆ¶æŒ‰é’®ç»„ - è‡ªé€‚åº” */
    #controlButtons {
        display: flex;
        gap: 1.5vw;
        margin-bottom: 1.5vw;
        justify-content: flex-end;
    }

    /* æ§åˆ¶æŒ‰é’®åŸºç¡€æ ·å¼ */
    .control-btn {
        width: 10vw;
        height: 10vw;
        max-width: 45px;
        max-height: 45px;
        border-radius: 50%;
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
        transition: all 0.3s ease;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    }

    /* èµ·ç‚¹æŒ‰é’® */
    .start-btn {
        background: linear-gradient(135deg, #4CAF50, #2E7D32);
        color: white;
    }

    .start-btn:hover {
        background: linear-gradient(135deg, #66BB6A, #388E3C);
        transform: scale(1.1);
    }

    .start-btn.active {
        background: linear-gradient(135deg, #2E7D32, #1B5E20);
        box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.5);
    }

    /* ç»ˆç‚¹æŒ‰é’® */
    .end-btn {
        background: linear-gradient(135deg, #F44336, #C62828);
        color: white;
    }

    .end-btn:hover {
        background: linear-gradient(135deg, #EF5350, #D32F2F);
        transform: scale(1.1);
    }

    .end-btn.active {
        background: linear-gradient(135deg, #C62828, #B71C1C);
        box-shadow: 0 0 0 3px rgba(244, 67, 54, 0.5);
    }

    /* æ·»åŠ è“è‰²è®¡ç®—æŒ‰é’®æ ·å¼ */
    .calc-btn {
        background: linear-gradient(135deg, #2196F3, #1976D2);
        color: white;
    }

    .calc-btn:hover {
        background: linear-gradient(135deg, #42A5F5, #1565C0);
        transform: scale(1.1);
    }

    .calc-btn.active {
        background: linear-gradient(135deg, #1976D2, #0D47A1);
        box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.5);
    }

    /* ä¿¡æ¯æ˜¾ç¤ºåŒºåŸŸ - æ•´ä½“æ ·å¼è°ƒæ•´ */
    #infoDisplay {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        font-size: 14px;
        line-height: 1.4;
        display: flex;
        flex-direction: column;
        gap: 8px;
        align-items: flex-end;
    }

    /* é€šç”¨ä¿¡æ¯æ¡†æ ·å¼ */
    #infoDisplay div {
        padding: 8px 12px;
        border-radius: 6px;
        background: rgba(255, 255, 255, 0.8);
        border-left: 4px solid;
        word-break: break-word;
        min-width: 150px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    /* èµ·ç‚¹ä¿¡æ¯æ¡† - ç»¿è‰²ç³» */
    #startInfo {
        border-left-color: #4CAF50;
        color: #2E7D32;
        margin-right: 0;
    }

    /* ç»ˆç‚¹ä¿¡æ¯æ¡† - çº¢è‰²ç³» */
    #endInfo {
        border-left-color: #F44336;
        color: #C62828;
        margin-right: 0;
    }

    /* è·¯å¾„ä¿¡æ¯æ¡† - è“è‰²ç³» */
    #pathInfo {
        border-left-color: #2196F3;
        color: #1976D2;
        margin-right: 0;
    }

    #infoDisplay div.door-info {
        border-left-color: #2196F3;
        color: #1976D2;
        background: rgba(33, 150, 243, 0.1);
    }

    /* è·¯å¾„ä¿¡æ¯æ ·å¼å¢å¼º */
    #pathInfo {
        position: relative;
        transition: all 0.3s ease;
        cursor: pointer;
    }

    #pathInfo:hover {
        transform: translateX(-5px);
    }

    /* ç®­å¤´æŒ‡ç¤ºå™¨ */
    .path-arrow-indicator {
        display: inline-block;
        margin-left: 8px;
        animation: arrowBounce 1s infinite;
    }

    @keyframes arrowBounce {
        0%, 100% { transform: translateX(0); }
        50% { transform: translateX(3px); }
    }

    /* è·¯å¾„ç»Ÿè®¡ä¿¡æ¯ */
    .path-stats {
        display: none;
        font-size: 12px;
        color: #666;
        margin-top: 5px;
        padding-top: 5px;
        border-top: 1px dashed #ddd;
    }

    #pathInfo:hover .path-stats {
        display: block;
    }
    
    /* ä¹¦æ¶ç‚¹å‡»æç¤º */
    .click-hint {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 15px 25px;
        border-radius: 10px;
        font-size: 16px;
        z-index: 1001;
        display: none;
        animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
    }
    
    
    /* å“åº”å¼è°ƒæ•´ */
    @media (max-width: 768px) {
        #apiTestPanel {
            position: relative;
            top: 0;
            left: 0;
            width: calc(100% - 40px);
            margin: 20px auto;
            max-width: none;
        }
    }
    </style>
</head>
<body>
 <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    /* ä½ çš„ 3D æ¸²æŸ“å®¹å™¨ï¼Œæ¯”å¦‚ #canvas-container */
    #canvas-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
  </style>
    <!-- åŸæœ‰çš„æ§åˆ¶é¢æ¿ -->
    <div id="controlsContainer">
        <div id="controlButtons">
            <button id="startBtn" class="control-btn start-btn" title="è®¾ç½®èµ·ç‚¹">
                <i class="fas fa-play"></i>
            </button>
            <button id="endBtn" class="control-btn end-btn" title="è®¾ç½®ç»ˆç‚¹">
                <i class="fas fa-flag"></i>
            </button>
            <button id="calcBtn" class="control-btn calc-btn" title="è®¡ç®—è·¯å¾„">
                <i class="fas fa-route"></i>
            </button>
        </div>
        <div id="infoDisplay">
            <div id="startInfo">èµ·ç‚¹: æœªè®¾ç½®</div>
            <div id="endInfo">ç»ˆç‚¹: æœªè®¾ç½®</div>
            <div id="pathInfo" class="path-info">è·¯å¾„: æœªè®¡ç®—</div>
        </div>
    </div>
    <script>
        const scene = new THREE.Scene();
        window.scene = scene;
        scene.background = new THREE.Color(0x87CEEB);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        const loader = new THREE.GLTFLoader();
        
        // 1. ç¯å¢ƒå…‰ï¼ˆç…§äº®æ‰€æœ‰è§’è½ï¼Œé¿å…æ­»é»‘ï¼‰
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.45);
        scene.add(ambientLight);

        // 2. ä¸»æ–¹å‘å…‰ï¼ˆæ¨¡æ‹Ÿå¤ªé˜³å…‰ï¼ŒæŠ•ä¸‹æŸ”å’Œé˜´å½±ï¼‰
        const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
        mainLight.position.set(30, 35, 20); // é«˜è§’åº¦æ–œå°„ï¼Œç¬¦åˆ100måœºæ™¯å°ºå¯¸
        mainLight.castShadow = true;

        // é˜´å½±å‚æ•°é€‚é…100måœºæ™¯
        mainLight.shadow.mapSize.width = 2048;
        mainLight.shadow.mapSize.height = 2048;
        mainLight.shadow.camera.near = 0.1;
        mainLight.shadow.camera.far = 150; // è¦†ç›–æ•´ä¸ª100måœºæ™¯
        mainLight.shadow.camera.left = -60;
        mainLight.shadow.camera.right = 60;
        mainLight.shadow.camera.top = 60;
        mainLight.shadow.camera.bottom = -60;
        mainLight.shadow.bias = -0.0001; // é¿å…é˜´å½±å¤±çœŸ
        mainLight.shadow.intensity = 0.6; // é˜´å½±æŸ”å’Œåº¦

        scene.add(mainLight);

        // 3. è¡¥å…‰ï¼ˆæ¶ˆé™¤ä¸»å…‰é€ æˆçš„ç¡¬é˜´å½±ï¼‰
        const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
        fillLight.position.set(-30, 30, -20);
        scene.add(fillLight);

        // å¤©è“è‰²é›¾ï¼Œå’Œä½ çš„èƒŒæ™¯ #87CEEB å®Œå…¨åŒ¹é…
        scene.fog = new THREE.FogExp2(0x87CEEB, 0.016);
        // ä¹¦æ¶ç‚¹å‡»ç³»ç»Ÿç›¸å…³å˜é‡
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let isSettingStart = false;
        let isSettingEnd = false;
        let startPoint = null;
        let endPoint = null;
        let startMarker = null;
        let endMarker = null;
        let clickableLayers = []; // æ‰€æœ‰å¯ç‚¹å‡»çš„ä¹¦æ¶å±‚
        let shelves = []; // æ‰€æœ‰ä¹¦æ¶å¯¹è±¡
        // åœ¨ç°æœ‰å˜é‡åæ·»åŠ 
        let doorLayers = [];
        // åœ¨ç°æœ‰å˜é‡åæ·»åŠ 
        let verticalConnectors = []; // å‚ç›´è¿æ¥çº¿æ•°ç»„
        // å¤§é—¨å‚æ•°
        const DOOR_PARAMS = {
            width: 2.0,
            height: 2.1,
            centerX: 0.5,
            centerY: 1.05,
            centerZ: -11.5,
            depth: 0.8
        };
        // ä¹¦æ¶å‚æ•°ï¼ˆåŸºäºåŸæœ‰ä¹¦æ¶å°ºå¯¸ï¼‰
        const SHELF_PARAMS = {
            width: 3.0,     // å®½3.0m
            height: 2.0,    // é«˜2.0m
            depth: 1.0,     // æ·±1.0m
            columns: 3,     // ä¸‰åˆ—
            rows: 4,        // å››å±‚
            columnWidth: 1.0,   // æ¯åˆ—å®½1.0m
            rowHeight: 0.5,     // æ¯å±‚é«˜0.5m
            frontOffset: 0.1,   // æ­£é¢åç§»
            backOffset: -0.1    // èƒŒé¢åç§»
        };
        // åœ¨å…¨å±€å˜é‡åŒºåŸŸæ·»åŠ å¤§é—¨ç»Ÿä¸€ä½ç½®
        const DOOR_UNIFIED_POSITION = {
            x: 0.5,          // å¤§é—¨ä¸­å¿ƒXåæ ‡
            y: 2.6,          // å¤§é—¨ç²¾çµçš„Yåæ ‡ (ä»createDoorSignå‡½æ•°è·å–)
            z: -11.3         // å¤§é—¨ç²¾çµçš„Zåæ ‡
        };

        // ========== è·¯å¾„è§„åˆ’ç½‘æ ¼ç³»ç»Ÿ ==========
        // ç½‘æ ¼å‚æ•°
        const GRID_SIZE = 0.5; // æ ¼å­å¤§å°0.5m
        const GRID_Y = 0.01;   // ç½‘æ ¼é«˜åº¦ï¼ˆç•¥é«˜äºåœ°é¢é˜²æ­¢ç©¿æ¨¡ï¼‰
        const GRID_X_MIN = -8.5; // å›¾ä¹¦é¦†è¥¿å¢™
        const GRID_X_MAX = 8.5;  // å›¾ä¹¦é¦†ä¸œå¢™
        const GRID_Z_MIN = -11.5; // å›¾ä¹¦é¦†å—å¢™
        const GRID_Z_MAX = 9.5;   // å›¾ä¹¦é¦†åŒ—å¢™

        // è®¡ç®—ç½‘æ ¼ç»´åº¦ï¼ˆç¡®ä¿åŸç‚¹æ˜¯ç½‘æ ¼äº¤ç‚¹ï¼‰
        const GRID_COLS = Math.floor((GRID_X_MAX - GRID_X_MIN) / GRID_SIZE) + 1;
        const GRID_ROWS = Math.floor((GRID_Z_MAX - GRID_Z_MIN) / GRID_SIZE) + 1;

        console.log(`ç½‘æ ¼ç³»ç»Ÿ: ${GRID_COLS}åˆ—Ã—${GRID_ROWS}è¡Œ, åŸç‚¹(${GRID_X_MIN}, ${GRID_Z_MIN})`);

            // åŸæœ‰çš„3Dç³»ç»Ÿä»£ç ä¿æŒä¸å˜ï¼Œåªæ˜¯æ·»åŠ ä¸€äº›å…¨å±€å˜é‡çš„å£°æ˜
            // ç¡®ä¿APIå¯ä»¥è®¿é—®çš„å…³é”®å…¨å±€å˜é‡
            
            // ========== å…¨å±€å˜é‡å£°æ˜ ==========
            // è¿™äº›å˜é‡åœ¨åŸæœ‰ä»£ç ä¸­å·²ç»å®šä¹‰ï¼Œè¿™é‡Œç¡®ä¿å®ƒä»¬åœ¨å…¨å±€ä½œç”¨åŸŸå¯è®¿é—®
            window.clickableLayers = [];
            window.doorLayers = [];
            window.shelves = [];
            window.startPoint = null;
            window.endPoint = null;
            window.startMarker = null;
            window.endMarker = null;
            window.pathLine = null;
            window.verticalConnectors = [];
            window.isSettingStart = false;
            window.isSettingEnd = false;
            window.gridMap = [];

        // ç½‘æ ¼èŠ‚ç‚¹ç±»
        class GridNode {
            constructor(gridX, gridZ) {
                this.gridX = gridX; // ç½‘æ ¼Xç´¢å¼•
                this.gridZ = gridZ; // ç½‘æ ¼Zç´¢å¼•
                this.worldX = GRID_X_MIN + gridX * GRID_SIZE; // ä¸–ç•ŒXåæ ‡
                this.worldZ = GRID_Z_MIN + gridZ * GRID_SIZE; // ä¸–ç•ŒZåæ ‡
                this.worldY = GRID_Y; // ä¸–ç•ŒYåæ ‡
                
                this.walkable = true; // æ˜¯å¦å¯é€šè¡Œ
                this.type = 'normal'; // èŠ‚ç‚¹ç±»å‹: normal, shelf, forbidden_area, reading_area
                this.parent = null;   // A*çˆ¶èŠ‚ç‚¹
                this.g = Infinity;           // ä»èµ·ç‚¹åˆ°å½“å‰èŠ‚ç‚¹çš„ä»£ä»·
                this.h = 0;           // å¯å‘å¼ä»£ä»·
                this.f = Infinity;           // æ€»ä»£ä»·
                
                // é‚»å±…èŠ‚ç‚¹ï¼ˆ8æ–¹å‘ï¼‰
                this.neighbors = [];
            }
        }

        // ç½‘æ ¼ç³»ç»Ÿ
        let gridMap = [];
        let pathLine = null; // è·¯å¾„çº¿å¯¹è±¡

        // ========== A*è·¯å¾„è§„åˆ’ç®—æ³• ==========
        class AStarPathfinder {
            constructor(grid) {
                this.grid = grid;
            }
            
            // è·å–èŠ‚ç‚¹çš„8ä¸ªé‚»å±…
            getNeighbors(node) {
                const neighbors = [];
                const directions = [
                    {dx: -1, dz: 0, cost: 1.0},   // å·¦
                    {dx: 1, dz: 0, cost: 1.0},    // å³
                    {dx: 0, dz: -1, cost: 1.0},   // ä¸Š
                    {dx: 0, dz: 1, cost: 1.0},    // ä¸‹
                    {dx: -1, dz: -1, cost: 1.414}, // å·¦ä¸Š
                    {dx: 1, dz: -1, cost: 1.414},  // å³ä¸Š
                    {dx: -1, dz: 1, cost: 1.414},  // å·¦ä¸‹
                    {dx: 1, dz: 1, cost: 1.414}    // å³ä¸‹
                ];
                
                for (const dir of directions) {
                    const newX = node.gridX + dir.dx;
                    const newZ = node.gridZ + dir.dz;
                    
                    // æ£€æŸ¥è¾¹ç•Œ
                    if (newX >= 0 && newX < GRID_COLS && newZ >= 0 && newZ < GRID_ROWS) {
                        const neighbor = this.grid[newZ][newX];
                        
                        // æ£€æŸ¥æ˜¯å¦å¯é€šè¡Œ
                        if (neighbor.walkable) {
                            // å¯¹äºå¯¹è§’çº¿ç§»åŠ¨ï¼Œéœ€è¦ç¡®ä¿ä¸¤ä¾§ç›´çº¿æ–¹å‘ä¹Ÿå¯é€šè¡Œ
                            if (Math.abs(dir.dx) === 1 && Math.abs(dir.dz) === 1) {
                                const side1 = this.grid[node.gridZ + dir.dz][node.gridX];
                                const side2 = this.grid[node.gridZ][node.gridX + dir.dx];
                                
                                if (side1.walkable && side2.walkable) {
                                    neighbors.push({node: neighbor, cost: dir.cost});
                                }
                            } else {
                                neighbors.push({node: neighbor, cost: dir.cost});
                            }
                        }
                    }
                }
                
                return neighbors;
            }
            
            // æ¬§å‡ é‡Œå¾—è·ç¦»å¯å‘å‡½æ•°
            heuristic(nodeA, nodeB) {
                const dx = nodeA.gridX - nodeB.gridX;
                const dz = nodeA.gridZ - nodeB.gridZ;
                return Math.sqrt(dx * dx + dz * dz);
            }
            
            // ä¸»å¯»è·¯å‡½æ•°
            findPath(startNode, endNode) {
                // èµ·ç‚¹ç»ˆç‚¹æ£€æŸ¥
                if (!startNode.walkable) {
                    console.error("èµ·ç‚¹ä¸å¯é€šè¡Œ");
                    return null;
                }
                
                if (!endNode.walkable) {
                    console.error("ç»ˆç‚¹ä¸å¯é€šè¡Œ");
                    return null;
                }
                
                const openSet = [];
                const closedSet = new Set();
                
                // åˆå§‹åŒ–èµ·ç‚¹
                startNode.g = 0;
                startNode.h = this.heuristic(startNode, endNode);
                startNode.f = startNode.g + startNode.h;
                
                openSet.push(startNode);
                
                while (openSet.length > 0) {
                    // è·å–Få€¼æœ€å°çš„èŠ‚ç‚¹
                    let currentNode = openSet[0];
                    let currentIndex = 0;
                    
                    for (let i = 1; i < openSet.length; i++) {
                        if (openSet[i].f < currentNode.f) {
                            currentNode = openSet[i];
                            currentIndex = i;
                        }
                    }
                    
                    // å¦‚æœæ‰¾åˆ°ç»ˆç‚¹
                    if (currentNode === endNode) {
                        const path = [];
                        let current = currentNode;
                        while (current) {
                            path.push({
                                x: current.worldX,
                                y: GRID_Y + 0.02, // ç•¥é«˜äºç½‘æ ¼é¿å…æ¸²æŸ“é—®é¢˜
                                z: current.worldZ
                            });
                            current = current.parent;
                        }
                        return path.reverse();
                    }
                    
                    // å°†å½“å‰èŠ‚ç‚¹ç§»åˆ°closedSet
                    openSet.splice(currentIndex, 1);
                    closedSet.add(currentNode);
                    
                    // è·å–é‚»å±…
                    const neighbors = this.getNeighbors(currentNode);
                    
                    for (const neighbor of neighbors) {
                        const neighborNode = neighbor.node;
                        
                        // å¦‚æœå·²åœ¨closedSetä¸­ï¼Œè·³è¿‡
                        if (closedSet.has(neighborNode)) {
                            continue;
                        }
                        
                        // è®¡ç®—æ–°çš„Gå€¼
                        const tentativeG = currentNode.g + neighbor.cost;
                        
                        // å¦‚æœè¿™æ˜¯æ›´å¥½çš„è·¯å¾„
                        if (tentativeG < neighborNode.g || !openSet.includes(neighborNode)) {
                            neighborNode.parent = currentNode;
                            neighborNode.g = tentativeG;
                            neighborNode.h = this.heuristic(neighborNode, endNode);
                            neighborNode.f = neighborNode.g + neighborNode.h;
                            
                            if (!openSet.includes(neighborNode)) {
                                openSet.push(neighborNode);
                            }
                        }
                    }
                }
                
                // æœªæ‰¾åˆ°è·¯å¾„
                console.warn("æœªæ‰¾åˆ°è·¯å¾„");
                return null;
            }
        }

        // ========== åæ ‡è½¬æ¢å‡½æ•° ==========
        // ä¸–ç•Œåæ ‡ -> ç½‘æ ¼ç´¢å¼•
        function worldToGridIndex(worldX, worldZ) {
            const gridX = Math.round((worldX - GRID_X_MIN) / GRID_SIZE);
            const gridZ = Math.round((worldZ - GRID_Z_MIN) / GRID_SIZE);
            
            // ç¡®ä¿åœ¨ç½‘æ ¼èŒƒå›´å†…
            return {
                x: Math.max(0, Math.min(gridX, GRID_COLS - 1)),
                z: Math.max(0, Math.min(gridZ, GRID_ROWS - 1))
            };
        }

        // ç½‘æ ¼ç´¢å¼• -> ä¸–ç•Œåæ ‡
        function gridIndexToWorld(gridX, gridZ) {
            return {
                x: GRID_X_MIN + gridX * GRID_SIZE,
                z: GRID_Z_MIN + gridZ * GRID_SIZE,
                y: GRID_Y
            };
        }

        // ========== åˆå§‹åŒ–ç½‘æ ¼åœ°å›¾ ==========
        function initGridMap() {
            console.log("åˆå§‹åŒ–ç½‘æ ¼åœ°å›¾...");
            
            // åˆ›å»ºç©ºçš„ç½‘æ ¼
            gridMap = [];
            for (let z = 0; z < GRID_ROWS; z++) {
                gridMap[z] = [];
                for (let x = 0; x < GRID_COLS; x++) {
                    gridMap[z][x] = new GridNode(x, z);
                }
            }
            
            // æ ‡è®°æ‰€æœ‰éšœç¢ç‰©
            markAllObstacles();
            
            console.log("ç½‘æ ¼åœ°å›¾åˆå§‹åŒ–å®Œæˆ");
        }

        // ========== æ ‡è®°æ‰€æœ‰éšœç¢ç‰© ==========
        // ========== æ ‡è®°æ‰€æœ‰éšœç¢ç‰© ==========
        // ========== æ ‡è®°æ‰€æœ‰éšœç¢ç‰© ==========
        function markAllObstacles() {
        // 1. é‡æ–°åˆå§‹åŒ–ç½‘æ ¼ä¸ºå…¨å¯é€šè¡Œ
        resetGridWalkability();
        
        // 2. æ ‡è®°å›ºå®šéšœç¢ç‰©
        markBookshelfObstacles();      // ä¹¦æ¶
        markForbiddenArea();           // ç¦æ­¢åŒºåŸŸ
        //markTablesAsObstacles();       // âœ… æ–°å¢è¿™è¡Œ
        
        // 3. æ ‡è®°é˜…è§ˆåŒºï¼ˆæ¡ä»¶éšœç¢ç‰©ï¼‰
        markReadingArea();
        
        // 4. å¼ºåˆ¶æ ‡è®°ç‰¹æ®Šä¹¦æ¶ä¸ºéšœç¢ç‰©
        forceMarkSpecialShelvesAsObstacles();
    }

        // ========== æ ‡è®°æ¡Œæ¤…ä¸ºå›ºå®šéšœç¢ç‰© ==========
        // ========== æ ‡è®°æ¡Œæ¤…ä¸ºå›ºå®šéšœç¢ç‰© ==========
        function markTablesAsObstacles() {
            console.log("æ ‡è®°æ¡Œæ¤…ä¸ºå›ºå®šéšœç¢ç‰©...");
            
            // æ¡Œæ¤…å°ºå¯¸ï¼šxæ–¹å‘2.0mï¼Œzæ–¹å‘3.0m
            // å››ä¸ªæ¡Œæ¤…çš„å®é™…åº•é¢ä¸­å¿ƒåæ ‡ï¼š
            const tables = [
                {x: -2.0, z: -3.5, widthX: 2.0, depthZ: 3.0, index: 1},
                {x: -6.0, z: -3.5, widthX: 2.0, depthZ: 3.0, index: 2},
                {x: -2.0, z: -6.5, widthX: 2.0, depthZ: 3.0, index: 3},
                {x: -6.0, z: -6.5, widthX: 2.0, depthZ: 3.0, index: 4}
            ];
            
            tables.forEach(table => {
                const minX = table.x - table.widthX/2;
                const maxX = table.x + table.widthX/2;
                const minZ = table.z - table.depthZ/2;
                const maxZ = table.z + table.depthZ/2;
                
                markRectangleObstacle(minX, maxX, minZ, maxZ, 'table', table.index);
            });
        }

        // ========== é‡ç½®ç½‘æ ¼é€šè¡Œæ€§ ==========
        function resetGridWalkability() {
        console.log("é‡ç½®ç½‘æ ¼é€šè¡Œæ€§...");
        
        for (let z = 0; z < GRID_ROWS; z++) {
            for (let x = 0; x < GRID_COLS; x++) {
                const node = gridMap[z][x];
                
                // âœ… ä¿®æ”¹ï¼šåŒ…å« 'table' ç±»å‹
                if (node.type === 'shelf' || node.type === 'forbidden_area' || node.type === 'table') {
                    node.walkable = false;  // å›ºå®šéšœç¢ç‰©
                } else {
                    node.walkable = true;   // å¯é€šè¡Œ
                }
            }
        }
    }

        // ========== æ ‡è®°ä¹¦æ¶éšœç¢ç‰© ==========
        // ========== æ ‡è®°ä¹¦æ¶éšœç¢ç‰© ==========
        // ========== æ ‡è®°ä¹¦æ¶éšœç¢ç‰© ==========
        function markBookshelfObstacles() {
            const shelfWidth = 3.0;
            const shelfDepth = 1.0;
            
            // ä¸»ç½‘æ ¼ä¹¦æ¶ (1-12å·)
            for (let z = 0; z < 4; z++) {
                const xOffsets = [-5, 0, 5];
                xOffsets.forEach((centerX, colIndex) => {
                    const centerZ = 0.5 + z * 2;
                    const shelfIndex = z * 3 + colIndex + 1;
                    
                    // è®¡ç®—ä¹¦æ¶å æ®çš„ç½‘æ ¼èŒƒå›´
                    const minX = centerX - shelfWidth/2;
                    const maxX = centerX + shelfWidth/2;
                    const minZ = centerZ - shelfDepth/2;
                    const maxZ = centerZ + shelfDepth/2;
                    
                    markRectangleObstacle(minX, maxX, minZ, maxZ, 'shelf', shelfIndex);
                });
            }
            
            // ç‰¹æ®Šä½ç½®ä¹¦æ¶ (13-14å·ï¼Œæ—‹è½¬90åº¦)
            const specialShelves = [
                {x: -4, z: -3.5, index: 13, rotation: 90},
                {x: -4, z: -7.5, index: 14, rotation: 90}
            ];
            
            specialShelves.forEach(shelf => {
                // æ—‹è½¬90åº¦åï¼Œå®½åº¦å˜æ·±åº¦ï¼Œæ·±åº¦å˜å®½åº¦
                const rotatedWidth = shelfDepth;   // 1.0m
                const rotatedDepth = shelfWidth;   // 3.0m
                
                // è®¡ç®—æ—‹è½¬åçš„è¾¹ç•Œ
                const minX = shelf.x - rotatedWidth/2;
                const maxX = shelf.x + rotatedWidth/2;
                const minZ = shelf.z - rotatedDepth/2;
                const maxZ = shelf.z + rotatedDepth/2;
                
                // ğŸ“Œ å…³é”®ä¿®æ”¹ï¼šæ°¸è¿œæ ‡è®°ç‰¹æ®Šä¹¦æ¶ä¸ºéšœç¢ç‰©
                markRectangleObstacle(minX, maxX, minZ, maxZ, 'shelf', shelf.index);
            });
        }

        // ========== å¼ºåˆ¶æ ‡è®°ç‰¹æ®Šä¹¦æ¶ä¸ºéšœç¢ç‰© ==========
        function forceMarkSpecialShelvesAsObstacles() {
            console.log("å¼ºåˆ¶æ ‡è®°ç‰¹æ®Šä¹¦æ¶13å’Œ14ä¸ºéšœç¢ç‰©...");
            
            // ç‰¹æ®Šä¹¦æ¶13
            const shelf13 = {x: -4, z: -3.5, width: 1.0, depth: 3.0, index: 13};
            markSpecialShelf(shelf13);
            
            // ç‰¹æ®Šä¹¦æ¶14
            const shelf14 = {x: -4, z: -7.5, width: 1.0, depth: 3.0, index: 14};
            markSpecialShelf(shelf14);
        }

        // ========== æ ‡è®°å•ä¸ªç‰¹æ®Šä¹¦æ¶ ==========
        function markSpecialShelf(shelf) {
            const minX = shelf.x - shelf.width/2;
            const maxX = shelf.x + shelf.width/2;
            const minZ = shelf.z - shelf.depth/2;
            const maxZ = shelf.z + shelf.depth/2;
            
            // è½¬æ¢åˆ°ç½‘æ ¼åæ ‡
            const gridMin = worldToGridIndex(minX, minZ);
            const gridMax = worldToGridIndex(maxX, maxZ);
            
            // æ ‡è®°çŸ©å½¢å†…çš„æ‰€æœ‰ç½‘æ ¼èŠ‚ç‚¹
            for (let z = gridMin.z; z <= gridMax.z; z++) {
                for (let x = gridMin.x; x <= gridMax.x; x++) {
                    if (z >= 0 && z < GRID_ROWS && x >= 0 && x < GRID_COLS) {
                        const node = gridMap[z][x];
                        
                        // æ£€æŸ¥è¿™ä¸ªèŠ‚ç‚¹æ˜¯å¦æ˜¯èµ·ç‚¹æˆ–ç»ˆç‚¹ä½ç½®
                        const worldPos = gridIndexToWorld(x, z);
                        let isStartEndPoint = false;
                        
                        // æ£€æŸ¥æ˜¯å¦æ˜¯èµ·ç‚¹
                        if (startPoint && startPoint.position) {
                            const dist = Math.sqrt(
                                Math.pow(worldPos.x - startPoint.position.x, 2) +
                                Math.pow(worldPos.z - startPoint.position.z, 2)
                            );
                            if (dist < 0.2) { // 0.2ç±³èŒƒå›´å†…
                                isStartEndPoint = true;
                                console.log(`ä¿ç•™ä¹¦æ¶${shelf.index}èµ·ç‚¹ä½ç½®ä¸ºå¯é€šè¡Œ: (${x},${z})`);
                            }
                        }
                        
                        // æ£€æŸ¥æ˜¯å¦æ˜¯ç»ˆç‚¹
                        if (endPoint && endPoint.position && !isStartEndPoint) {
                            const dist = Math.sqrt(
                                Math.pow(worldPos.x - endPoint.position.x, 2) +
                                Math.pow(worldPos.z - endPoint.position.z, 2)
                            );
                            if (dist < 0.2) { // 0.2ç±³èŒƒå›´å†…
                                isStartEndPoint = true;
                                console.log(`ä¿ç•™ä¹¦æ¶${shelf.index}ç»ˆç‚¹ä½ç½®ä¸ºå¯é€šè¡Œ: (${x},${z})`);
                            }
                        }
                        
                        // å¦‚æœä¸æ˜¯èµ·ç‚¹/ç»ˆç‚¹ä½ç½®ï¼Œæ ‡è®°ä¸ºéšœç¢ç‰©
                        if (!isStartEndPoint) {
                            node.walkable = false;
                            node.type = 'shelf';
                        } else {
                            // èµ·ç‚¹/ç»ˆç‚¹ä½ç½®ä¿æŒå¯é€šè¡Œ
                            node.walkable = true;
                            node.type = 'normal';
                        }
                    }
                }
            }
            
            console.log(`å¼ºåˆ¶æ ‡è®°ä¹¦æ¶${shelf.index}ä¸ºéšœç¢ç‰©: (${minX},${minZ})åˆ°(${maxX},${maxZ})`);
        }

                // ========== ç®€åŒ–çš„ç‰¹æ®Šä¹¦æ¶éšœç¢ç‰©æ ‡è®° ==========
        // ========== ç®€åŒ–çš„ç‰¹æ®Šä¹¦æ¶éšœç¢ç‰©æ ‡è®° ==========
        function markActiveSpecialShelfObstacle(minX, maxX, minZ, maxZ, shelfIndex, centerX, centerZ, rotation) {
            // å¯¹äºä½œä¸ºèµ·ç‚¹/ç»ˆç‚¹çš„ç‰¹æ®Šä¹¦æ¶ï¼Œæˆ‘ä»¬åªæ ‡è®°ä¹¦æ¶çš„æ ¸å¿ƒåŒºåŸŸä¸ºéšœç¢ç‰©
            // åœ¨ä¹¦æ¶å‘¨å›´ç•™å‡ºè¶³å¤Ÿçš„ç©ºé—´ä¾›èµ·ç‚¹/ç»ˆç‚¹ä½¿ç”¨
            
            // ä¹¦æ¶æ ¸å¿ƒåŒºåŸŸï¼ˆæ¯”å®é™…ä¹¦æ¶å°ä¸€åœˆï¼‰
            const coreMinX = centerX - 0.4;  // å®é™…å®½åº¦1mï¼Œæ ¸å¿ƒåŒºåŸŸ0.8m
            const coreMaxX = centerX + 0.4;
            const coreMinZ = centerZ - 1.4;  // å®é™…æ·±åº¦3mï¼Œæ ¸å¿ƒåŒºåŸŸ2.8m
            const coreMaxZ = centerZ + 1.4;
            
            // æ ‡è®°æ ¸å¿ƒåŒºåŸŸä¸ºéšœç¢ç‰©
            const coreGridMin = worldToGridIndex(coreMinX, coreMinZ);
            const coreGridMax = worldToGridIndex(coreMaxX, coreMaxZ);
            
            for (let z = coreGridMin.z; z <= coreGridMax.z; z++) {
                for (let x = coreGridMin.x; x <= coreGridMax.x; x++) {
                    if (z >= 0 && z < GRID_ROWS && x >= 0 && x < GRID_COLS) {
                        gridMap[z][x].walkable = false;
                        gridMap[z][x].type = 'shelf';
                    }
                }
            }
            
            console.log(`ç‰¹æ®Šä¹¦æ¶${shelfIndex}ï¼šæ ‡è®°æ ¸å¿ƒåŒºåŸŸä¸ºéšœç¢ç‰©ï¼Œå‘¨å›´ç•™å‡ºé€šé“`);
        }

// ========== æ ‡è®°ä½œä¸ºèµ·ç‚¹/ç»ˆç‚¹çš„æ™®é€šä¹¦æ¶éšœç¢ç‰© ==========
        function markActiveShelfObstacle(minX, maxX, minZ, maxZ, shelfIndex, centerX, centerZ) {
            // å¯¹äºä½œä¸ºèµ·ç‚¹/ç»ˆç‚¹çš„æ™®é€šä¹¦æ¶ï¼Œæ ‡è®°å¤§éƒ¨åˆ†åŒºåŸŸä¸ºéšœç¢ç‰©
            // ä½†åœ¨èµ·ç‚¹/ç»ˆç‚¹ä½ç½®é™„è¿‘ç•™å‡ºé€šé“
            
            // è½¬æ¢åˆ°ç½‘æ ¼åæ ‡
            const gridMin = worldToGridIndex(minX, minZ);
            const gridMax = worldToGridIndex(maxX, maxZ);
            
            // è·å–èµ·ç‚¹/ç»ˆç‚¹ä½ç½®ï¼ˆå¦‚æœåœ¨è¿™ä¸ªä¹¦æ¶ä¸Šï¼‰
            let startPos = null;
            let endPos = null;
            
            if (startPoint && startPoint.shelfIndex === shelfIndex) {
                startPos = startPoint.position;
            }
            
            if (endPoint && endPoint.shelfIndex === shelfIndex) {
                endPos = endPoint.position;
            }
            
            // æ ‡è®°ä¹¦æ¶å¤§éƒ¨åˆ†åŒºåŸŸä¸ºéšœç¢ç‰©ï¼Œä½†ä¸ºèµ·ç‚¹/ç»ˆç‚¹ç•™å‡ºç©ºé—´
            for (let z = gridMin.z; z <= gridMax.z; z++) {
                for (let x = gridMin.x; x <= gridMax.x; x++) {
                    if (z >= 0 && z < GRID_ROWS && x >= 0 && x < GRID_COLS) {
                        const worldPos = gridIndexToWorld(x, z);
                        
                        // è®¡ç®—åˆ°èµ·ç‚¹/ç»ˆç‚¹çš„è·ç¦»
                        let isStartEndArea = false;
                        
                        if (startPos) {
                            const distToStart = Math.sqrt(
                                Math.pow(worldPos.x - startPos.x, 2) + 
                                Math.pow(worldPos.z - startPos.z, 2)
                            );
                            if (distToStart < 0.3) { // 0.3ç±³èŒƒå›´å†…
                                isStartEndArea = true;
                            }
                        }
                        
                        if (endPos && !isStartEndArea) {
                            const distToEnd = Math.sqrt(
                                Math.pow(worldPos.x - endPos.x, 2) + 
                                Math.pow(worldPos.z - endPos.z, 2)
                            );
                            if (distToEnd < 0.3) { // 0.3ç±³èŒƒå›´å†…
                                isStartEndArea = true;
                            }
                        }
                        
                        // å¦‚æœæ˜¯èµ·ç‚¹/ç»ˆç‚¹åŒºåŸŸï¼Œä¿æŒå¯é€šè¡Œï¼Œå¦åˆ™æ ‡è®°ä¸ºéšœç¢ç‰©
                        if (!isStartEndArea) {
                            gridMap[z][x].walkable = false;
                            gridMap[z][x].type = 'shelf';
                        } else {
                            // èµ·ç‚¹/ç»ˆç‚¹åŒºåŸŸï¼Œç¡®ä¿å¯é€šè¡Œ
                            gridMap[z][x].walkable = true;
                            gridMap[z][x].type = 'normal';
                        }
                    }
                }
            }
            
            console.log(`ä¹¦æ¶${shelfIndex}ï¼šæ ‡è®°ä¸ºéšœç¢ç‰©ï¼Œä½†ä¸ºèµ·ç‚¹/ç»ˆç‚¹ç•™å‡ºç©ºé—´`);
        }

        // ========== æ ‡è®°çŸ©å½¢éšœç¢ç‰© ==========
        function markRectangleObstacle(minX, maxX, minZ, maxZ, type, index = 0) {
            // è½¬æ¢åˆ°ç½‘æ ¼åæ ‡
            const gridMin = worldToGridIndex(minX, minZ);
            const gridMax = worldToGridIndex(maxX, maxZ);
            
            // æ ‡è®°çŸ©å½¢å†…çš„æ‰€æœ‰ç½‘æ ¼èŠ‚ç‚¹
            for (let z = gridMin.z; z <= gridMax.z; z++) {
                for (let x = gridMin.x; x <= gridMax.x; x++) {
                    if (z >= 0 && z < GRID_ROWS && x >= 0 && x < GRID_COLS) {
                        gridMap[z][x].walkable = false;
                        gridMap[z][x].type = type;
                    }
                }
            }
            
            console.log(`æ ‡è®°${type}éšœç¢ç‰©${index}: (${minX},${minZ})åˆ°(${maxX},${maxZ})`);
        }

        // ========== æ ‡è®°ç¦æ­¢é€šè¡ŒåŒºåŸŸ ==========
        function markForbiddenArea() {
            const minX = 2.1;
            const maxX = GRID_X_MAX;
            const minZ = GRID_Z_MIN;
            const maxZ = -1.5;
            
            // è½¬æ¢åˆ°ç½‘æ ¼åæ ‡
            const gridMin = worldToGridIndex(minX, minZ);
            const gridMax = worldToGridIndex(maxX, maxZ);
            
            // æ ‡è®°åŒºåŸŸå†…çš„æ‰€æœ‰ç½‘æ ¼èŠ‚ç‚¹
            for (let z = gridMin.z; z <= gridMax.z; z++) {
                for (let x = gridMin.x; x <= gridMax.x; x++) {
                    if (z >= 0 && z < GRID_ROWS && x >= 0 && x < GRID_COLS) {
                        // åªæ ‡è®°å½“å‰å¯é€šè¡Œçš„èŠ‚ç‚¹ï¼ˆé¿å…è¦†ç›–ä¹¦æ¶ï¼‰
                        if (gridMap[z][x].walkable) {
                            gridMap[z][x].walkable = false;
                            gridMap[z][x].type = 'forbidden_area';
                        }
                    }
                }
            }
            
            console.log(`æ ‡è®°ç¦æ­¢é€šè¡ŒåŒºåŸŸ: x>${minX}ä¸”z<${maxZ}`);
        }

        // ========== æ ‡è®°é˜…è§ˆåŒºï¼ˆæ¡ä»¶éšœç¢ç‰©ï¼‰ ==========
        // ========== æ ‡è®°é˜…è§ˆåŒºï¼ˆæ¡ä»¶éšœç¢ç‰©ï¼‰ ==========
        // ========== æ ‡è®°é˜…è§ˆåŒºï¼ˆæ¡ä»¶éšœç¢ç‰©ï¼‰ ==========
        function markReadingArea() {
        const minX = GRID_X_MIN;
        const maxX = -0.5;
        const minZ = GRID_Z_MIN;
        const maxZ = -2.0;
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦å¼€æ”¾é˜…è§ˆåŒº
        const shouldOpenReadingArea = (startPoint && (startPoint.shelfIndex === 13 || startPoint.shelfIndex === 14)) ||
                                    (endPoint && (endPoint.shelfIndex === 13 || endPoint.shelfIndex === 14));
        
        console.log(`é˜…è§ˆåŒºçŠ¶æ€: ${shouldOpenReadingArea ? 'å¼€æ”¾ï¼ˆå¯é€šè¡Œï¼‰' : 'å…³é—­ï¼ˆä¸å¯é€šè¡Œï¼‰'}`);
        
        if (!shouldOpenReadingArea) {
            // å¦‚æœä¸éœ€è¦å¼€æ”¾é˜…è§ˆåŒºï¼Œæ ‡è®°ä¸ºéšœç¢ç‰©
            const gridMin = worldToGridIndex(minX, minZ);
            const gridMax = worldToGridIndex(maxX, maxZ);
            
            // âœ… ç®€åŒ–ç‰ˆæœ¬ï¼šåªæ ‡è®°éå›ºå®šéšœç¢ç‰©åŒºåŸŸ
            for (let z = gridMin.z; z <= gridMax.z; z++) {
                for (let x = gridMin.x; x <= gridMax.x; x++) {
                    if (z >= 0 && z < GRID_ROWS && x >= 0 && x < GRID_COLS) {
                        const node = gridMap[z][x];
                        // åªæ ‡è®°ä¸æ˜¯å›ºå®šéšœç¢ç‰©çš„èŠ‚ç‚¹
                        if (node.type !== 'shelf' && node.type !== 'forbidden_area' && node.type !== 'table') {
                            node.walkable = false;
                            node.type = 'reading_area';
                        }
                    }
                }
            }
        }
    }

        // ========== è®¡ç®—å¹¶æ˜¾ç¤ºè·¯å¾„ ==========
        window.calculateAndShowPath = function() {
        console.log("=== å¼€å§‹è·¯å¾„è®¡ç®— ===");
        
        // å®‰å…¨æ£€æŸ¥
        if (!startPoint || !endPoint) {
            alert("è¯·å…ˆè®¾ç½®èµ·ç‚¹å’Œç»ˆç‚¹");
            return;
        }
        
        // 1. é‡ç½®ç½‘æ ¼èŠ‚ç‚¹çŠ¶æ€
        resetGridNodeStates();
        
        // 2. é‡æ–°æ ‡è®°éšœç¢ç‰©
        markAllObstacles();
        
        // 3. è·å–èµ·ç‚¹ç»ˆç‚¹ç½‘æ ¼èŠ‚ç‚¹
        let startGridPos, endGridPos;
        
        if (startPoint.isDoor) {
            startGridPos = worldToGridIndex(DOOR_UNIFIED_POSITION.x, DOOR_UNIFIED_POSITION.z);
        } else {
            startGridPos = worldToGridIndex(startPoint.position.x, startPoint.position.z);
        }
        
        if (endPoint.isDoor) {
            endGridPos = worldToGridIndex(DOOR_UNIFIED_POSITION.x, DOOR_UNIFIED_POSITION.z);
        } else {
            endGridPos = worldToGridIndex(endPoint.position.x, endPoint.position.z);
        }
        
        // 4. è·å–ç½‘æ ¼èŠ‚ç‚¹
        const startNode = gridMap[startGridPos.z][startGridPos.x];
        const endNode = gridMap[endGridPos.z][endGridPos.x];
        
        // 5. å¼ºåˆ¶ç¡®ä¿èµ·ç‚¹ç»ˆç‚¹å¯é€šè¡Œ
        startNode.walkable = true;
        endNode.walkable = true;
        
        console.log(`èµ·ç‚¹èŠ‚ç‚¹: (${startGridPos.x}, ${startGridPos.z}), ç±»å‹: ${startNode.type}`);
        console.log(`ç»ˆç‚¹èŠ‚ç‚¹: (${endGridPos.x}, ${endGridPos.z}), ç±»å‹: ${endNode.type}`);
        
        // 6. ä½¿ç”¨A*ç®—æ³•å¯»è·¯
        const pathfinder = new AStarPathfinder(gridMap);
        const path = pathfinder.findPath(startNode, endNode);
        
        if (path && path.length > 0) {
            console.log(`æ‰¾åˆ°è·¯å¾„ï¼ŒåŒ…å«${path.length}ä¸ªèŠ‚ç‚¹`);
            visualizePathWithArrows(path)
            updatePathInfo(path.length);
        } else {
            alert("æœªæ‰¾åˆ°å¯è¡Œè·¯å¾„");
            updatePathInfo(0);
        }
    }

        // ========== é‡ç½®ç½‘æ ¼èŠ‚ç‚¹çŠ¶æ€ï¼ˆA*ç®—æ³•ç›¸å…³çŠ¶æ€ï¼‰ ==========
        function resetGridNodeStates() {
            console.log("é‡ç½®ç½‘æ ¼èŠ‚ç‚¹A*ç®—æ³•çŠ¶æ€...");
            
            let resetCount = 0;
            
            for (let z = 0; z < GRID_ROWS; z++) {
                for (let x = 0; x < GRID_COLS; x++) {
                    const node = gridMap[z][x];
                    
                    // é‡ç½®A*ç®—æ³•ç›¸å…³çš„å±æ€§
                    node.parent = null;
                    node.g = Infinity;
                    node.h = 0;
                    node.f = Infinity;
                    
                    // æ¸…ç©ºé‚»å±…æ•°ç»„ï¼ˆå¦‚æœéœ€è¦é‡æ–°è®¡ç®—ï¼‰
                    // æ³¨æ„ï¼šå¦‚æœç½‘æ ¼ç»“æ„ä¸å˜ï¼Œé‚»å±…å…³ç³»ä¸éœ€è¦æ¯æ¬¡é‡ç½®
                    // node.neighbors = [];
                    
                    resetCount++;
                }
            }
            
            console.log(`å·²é‡ç½® ${resetCount} ä¸ªç½‘æ ¼èŠ‚ç‚¹çš„A*çŠ¶æ€`);
        }

        // ========== å¯è§†åŒ–è·¯å¾„ ==========
        // ========== å¯è§†åŒ–è·¯å¾„ï¼ˆå¸¦çŠ¶çš„è·¯å¾„å¹³é¢ï¼‰ ==========
        // ========== å¯è§†åŒ–è·¯å¾„ï¼ˆçœŸæ­£çš„äºŒç»´å¸¦çŠ¶å¹³é¢ï¼‰ ==========
    // ========== å¯è§†åŒ–è·¯å¾„ï¼ˆå¸¦ç™½è‰²ç®­å¤´çš„äºŒç»´å¸¦çŠ¶å¹³é¢ï¼‰ ==========
        // ========== å¯è§†åŒ–è·¯å¾„ï¼ˆå¸¦æ­£ç¡®æ–¹å‘ç®­å¤´çš„äºŒç»´å¸¦çŠ¶å¹³é¢ï¼‰ ==========
        function visualizePathWithArrows(path) {
            console.log("å¼€å§‹ç»˜åˆ¶å¸¦æ­£ç¡®æ–¹å‘ç®­å¤´çš„äºŒç»´å¸¦çŠ¶è·¯å¾„...");
            
            // 1. ç§»é™¤æ—§è·¯å¾„
            if (pathLine) {
                scene.remove(pathLine);
                pathLine = null;
            }
            
            if (path.length < 2) {
                console.warn("è·¯å¾„ç‚¹ä¸è¶³ï¼Œæ— æ³•ç»˜åˆ¶è·¯å¾„å¸¦");
                return;
            }
            
            // 2. é…ç½®å‚æ•°
            const PATH_WIDTH = 0.4; // è·¯å¾„å®½åº¦ï¼ˆç±³ï¼‰
            const PATH_COLOR = 0x2196F3; // è·¯å¾„é¢œè‰²ï¼ˆè“è‰²ï¼‰
            const PATH_OPACITY = 0.7; // è·¯å¾„é€æ˜åº¦
            const ARROW_COLOR = 0xFFFFFF; // ç®­å¤´é¢œè‰²ï¼ˆç™½è‰²ï¼‰
            
            // 3. åˆ›å»ºè·¯å¾„å¸¦å‡ ä½•ä½“
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const uvs = [];
            const indices = [];
            
            // ç”Ÿæˆå¸¦çŠ¶è·¯å¾„çš„é¡¶ç‚¹
            for (let i = 0; i < path.length; i++) {
                const point = path[i];
                
                // è®¡ç®—å½“å‰ç‚¹çš„åˆ‡çº¿æ–¹å‘ï¼ˆå‰è¿›æ–¹å‘ï¼‰
                let tangent;
                if (i === 0) {
                    // ç¬¬ä¸€ä¸ªç‚¹ï¼šä½¿ç”¨ä¸‹ä¸€ä¸ªç‚¹çš„æ–¹å‘
                    const nextPoint = path[i + 1];
                    tangent = new THREE.Vector3(
                        nextPoint.x - point.x,
                        0,
                        nextPoint.z - point.z
                    ).normalize();
                } else if (i === path.length - 1) {
                    // æœ€åä¸€ä¸ªç‚¹ï¼šä½¿ç”¨å‰ä¸€ä¸ªç‚¹çš„æ–¹å‘
                    const prevPoint = path[i - 1];
                    tangent = new THREE.Vector3(
                        point.x - prevPoint.x,
                        0,
                        point.z - prevPoint.z
                    ).normalize();
                } else {
                    // ä¸­é—´ç‚¹ï¼šä½¿ç”¨å‰åç‚¹çš„å¹³å‡æ–¹å‘
                    const prevPoint = path[i - 1];
                    const nextPoint = path[i + 1];
                    tangent = new THREE.Vector3(
                        nextPoint.x - prevPoint.x,
                        0,
                        nextPoint.z - prevPoint.z
                    ).normalize();
                }
                
                // è®¡ç®—å‚ç›´äºåˆ‡çº¿çš„æ³•çº¿ï¼ˆåœ¨XZå¹³é¢ä¸Šï¼‰ - è¿™æ˜¯æ­£ç¡®çš„
                const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                
                // è®¡ç®—å·¦å³è¾¹ç•Œç‚¹
                const leftPoint = new THREE.Vector3(
                    point.x + normal.x * PATH_WIDTH / 2,
                    point.y + 0.001, // ç¨å¾®æŠ¬é«˜é¿å…Z-fighting
                    point.z + normal.z * PATH_WIDTH / 2
                );
                
                const rightPoint = new THREE.Vector3(
                    point.x - normal.x * PATH_WIDTH / 2,
                    point.y + 0.001,
                    point.z - normal.z * PATH_WIDTH / 2
                );
                
                // æ·»åŠ é¡¶ç‚¹
                vertices.push(leftPoint.x, leftPoint.y, leftPoint.z);  // å·¦è¾¹ç•Œ
                vertices.push(rightPoint.x, rightPoint.y, rightPoint.z); // å³è¾¹ç•Œ
                
                // æ·»åŠ UVåæ ‡
                // å…³é”®ï¼šUæ–¹å‘æ²¿ç€è·¯å¾„å‰è¿›æ–¹å‘ï¼ŒVæ–¹å‘æ˜¯è·¯å¾„å®½åº¦æ–¹å‘
                const u = i / (path.length - 1);
                uvs.push(-u, 0);  // å·¦è¾¹UV
                uvs.push(-u, 1);  // å³è¾¹UV
            }
            
            // åˆ›å»ºä¸‰è§’å½¢ç´¢å¼•
            for (let i = 0; i < path.length - 1; i++) {
                const base = i * 2;
                indices.push(base, base + 1, base + 2);
                indices.push(base + 1, base + 3, base + 2);
            }
            
            // è®¾ç½®å‡ ä½•ä½“å±æ€§
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();
            
            // 4. åˆ›å»ºå¸¦ç®­å¤´çº¹ç†çš„æè´¨
            const texture = createDirectionalArrowTexture(PATH_COLOR, ARROW_COLOR);
            const material = new THREE.MeshLambertMaterial({
                map: texture,
                transparent: true,
                opacity: PATH_OPACITY,
                side: THREE.DoubleSide
            });
            
            // 5. è®¾ç½®çº¹ç†
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(path.length * 0.3, 1); // æ§åˆ¶ç®­å¤´å¯†åº¦
            
            // 6. åˆ›å»ºè·¯å¾„ç½‘æ ¼
            pathLine = new THREE.Mesh(geometry, material);
            scene.add(pathLine);
            
            // 7. è®¡ç®—è·¯å¾„é•¿åº¦å¹¶æ˜¾ç¤º
            const pathLength = calculatePathLength(path);
            updatePathInfo(pathLength);
            
            // 8. æ·»åŠ å‚ç›´è¿æ¥çº¿
            addVerticalConnectors(path[0], path[path.length - 1]);
            
            console.log(`å¸¦æ­£ç¡®æ–¹å‘ç®­å¤´çš„äºŒç»´è·¯å¾„å¸¦ç»˜åˆ¶å®Œæˆ`);
        }
        // ========== åˆ›å»ºæŒ‡å‘æ€§ç®­å¤´çº¹ç† ==========
        function createDirectionalArrowTexture(pathColor, arrowColor) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // è®¾ç½®ç”»å¸ƒå¤§å°ï¼ˆé•¿æ¡å½¢ï¼Œä¾¿äºç®­å¤´æ²¿ç€è·¯å¾„æ–¹å‘ï¼‰
            canvas.width = 512; // é•¿åº¦æ–¹å‘
            canvas.height = 128; // å®½åº¦æ–¹å‘
            
            // è®¡ç®—é¢œè‰²
            const pathColorHex = '#' + pathColor.toString(16).padStart(6, '0');
            const arrowColorHex = '#' + arrowColor.toString(16).padStart(6, '0');
            
            // 1. ç»˜åˆ¶è·¯å¾„èƒŒæ™¯ï¼ˆæ¸å˜æ•ˆæœï¼Œæ²¿å®½åº¦æ–¹å‘æ¸å˜ï¼‰
            const gradient = ctx.createLinearGradient(0, 0, canvas.height, 0);
            gradient.addColorStop(0, pathColorHex + 'AA'); // è¾¹ç¼˜åŠé€æ˜
            gradient.addColorStop(0.5, pathColorHex + 'FF'); // ä¸­é—´ä¸é€æ˜
            gradient.addColorStop(1, pathColorHex + 'AA'); // è¾¹ç¼˜åŠé€æ˜
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 2. ç»˜åˆ¶æ–¹å‘ç®­å¤´ï¼ˆæ²¿ç€é•¿åº¦æ–¹å‘ï¼‰
            // ç®­å¤´å‚æ•°
            const arrowSpacing = canvas.width / 5; // 5ä¸ªç®­å¤´
            const arrowLength = arrowSpacing * 0.4; // ç®­å¤´é•¿åº¦
            const arrowWidth = canvas.height * 0.6; // ç®­å¤´å®½åº¦
            
            ctx.fillStyle = arrowColorHex + 'FF';
            ctx.strokeStyle = arrowColorHex + 'FF';
            ctx.lineWidth = 2;
            
            for (let i = 0; i < 5; i++) {
                const x = i * arrowSpacing + arrowSpacing / 2;
                const y = canvas.height / 2;
                
                // ç»˜åˆ¶ç®­å¤´ï¼ˆä¸‰è§’å½¢ï¼ŒæŒ‡å‘å³è¾¹ï¼‰
                ctx.beginPath();
                ctx.moveTo(x - arrowLength / 2, y); // ç®­å¤´å°¾éƒ¨ä¸­å¿ƒ
                ctx.lineTo(x + arrowLength / 2, y - arrowWidth / 2); // ç®­å¤´å°–ç«¯å³ä¸Š
                ctx.lineTo(x + arrowLength / 2, y + arrowWidth / 2); // ç®­å¤´å°–ç«¯å³ä¸‹
                ctx.closePath();
                ctx.fill();
                
                // æ·»åŠ å‘å…‰æ•ˆæœ
                ctx.shadowColor = 'white';
                ctx.shadowBlur = 8;
                ctx.fill();
                ctx.shadowBlur = 0;
                
                // ç»˜åˆ¶ç®­å¤´ä¸­å¿ƒçº¿
                ctx.beginPath();
                ctx.moveTo(x - arrowLength / 2, y);
                ctx.lineTo(x + arrowLength / 2, y);
                ctx.stroke();
            }
            
            // 3. æ·»åŠ è·¯å¾„è¾¹ç¼˜çº¿
            ctx.strokeStyle = arrowColorHex + '80';
            ctx.lineWidth = 1;
            ctx.strokeRect(0, 0, canvas.width, canvas.height);
            
            // åˆ›å»ºThree.jsçº¹ç†
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            
            return texture;
        }
// ========== åˆ›å»ºç®­å¤´çº¹ç† ==========
        function createArrowTexture(pathColor, arrowColor, pathWidth) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // è®¾ç½®ç”»å¸ƒå¤§å°ï¼ˆå®½åº¦è¾ƒå¤§ä»¥å®¹çº³ç®­å¤´å›¾æ¡ˆï¼‰
            canvas.width = 512;
            canvas.height = 256;
            
            // æ¸…é™¤ç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // è®¡ç®—é¢œè‰²
            const pathColorHex = '#' + pathColor.toString(16).padStart(6, '0');
            const arrowColorHex = '#' + arrowColor.toString(16).padStart(6, '0');
            
            // ç»˜åˆ¶è·¯å¾„èƒŒæ™¯ï¼ˆæ¸å˜æ•ˆæœï¼‰
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, pathColorHex + 'CC');
            gradient.addColorStop(0.5, pathColorHex + '99');
            gradient.addColorStop(1, pathColorHex + 'CC');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶ç®­å¤´ï¼ˆç™½è‰²ä¸‰è§’å½¢ï¼‰
            const arrowCount = 8; // çº¹ç†ä¸­ç®­å¤´çš„æ•°é‡
            const arrowSpacing = canvas.width / arrowCount;
            const arrowWidth = canvas.width * 0.08; // ç®­å¤´å®½åº¦
            const arrowHeight = canvas.height * 0.6; // ç®­å¤´é«˜åº¦
            
            ctx.fillStyle = arrowColorHex + 'FF'; // ç™½è‰²ä¸é€æ˜
            
            for (let i = 0; i < arrowCount; i++) {
                const x = i * arrowSpacing + arrowSpacing / 2;
                const y = canvas.height / 2;
                
                // ç»˜åˆ¶ä¸‰è§’å½¢ç®­å¤´
                ctx.beginPath();
                ctx.moveTo(x, y - arrowHeight / 2); // é¡¶ç‚¹
                ctx.lineTo(x - arrowWidth / 2, y + arrowHeight / 2); // å·¦ä¸‹è§’
                ctx.lineTo(x + arrowWidth / 2, y + arrowHeight / 2); // å³ä¸‹è§’
                ctx.closePath();
                ctx.fill();
                
                // æ·»åŠ å‘å…‰æ•ˆæœ
                ctx.shadowColor = 'white';
                ctx.shadowBlur = 5;
                ctx.fill();
                ctx.shadowBlur = 0;
            }
            
            // æ·»åŠ è¾¹æ¡†
            ctx.strokeStyle = arrowColorHex + '80';
            ctx.lineWidth = 2;
            ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);
            
            // åˆ›å»ºThree.jsçº¹ç†
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            
            return texture;
        }

    // ========== ä¸ºè·¯å¾„åˆ›å»ºçº¹ç†ï¼ˆå¢å¼ºè§†è§‰æ•ˆæœï¼‰ ==========
        

        // ========== è®¡ç®—è·¯å¾„é•¿åº¦ ==========
        // ========== è®¡ç®—è·¯å¾„é•¿åº¦ ==========
        function calculatePathLength(path) {
            let length = 0;
            for (let i = 0; i < path.length - 1; i++) {
                const dx = path[i+1].x - path[i].x;
                const dz = path[i+1].z - path[i].z;
                length += Math.sqrt(dx * dx + dz * dz);
            }
            return length;
        }

        // ========== ç®€åŒ–ç‰ˆï¼šä½¿ç”¨å¹³é¢çš„å¸¦çŠ¶å‡ ä½•ä½“ ==========
        function visualizePathSimple(path) {
            console.log("å¼€å§‹ç»˜åˆ¶ç®€åŒ–ç‰ˆäºŒç»´è·¯å¾„å¸¦...");
            
            // ç§»é™¤æ—§è·¯å¾„
            if (pathLine) {
                scene.remove(pathLine);
                pathLine = null;
            }
            
            if (path.length < 2) return;
            
            // é…ç½®
            const PATH_WIDTH = 0.35;
            const PATH_COLOR = 0x2196F3;
            
            // åˆ›å»ºå‡ ä½•ä½“
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            
            // ç”Ÿæˆè·¯å¾„å¸¦é¡¶ç‚¹ï¼ˆç®€å•çš„å¸¦çŠ¶ï¼‰
            for (let i = 0; i < path.length; i++) {
                const point = path[i];
                
                if (i < path.length - 1) {
                    // è®¡ç®—ä¸¤ä¸ªç‚¹ä¹‹é—´çš„æ–¹å‘å’Œå‚ç›´æ–¹å‘
                    const nextPoint = path[i + 1];
                    const dx = nextPoint.x - point.x;
                    const dz = nextPoint.z - point.z;
                    const length = Math.sqrt(dx * dx + dz * dz);
                    
                    if (length > 0) {
                        const tangent = new THREE.Vector3(dx / length, 0, dz / length);
                        const normal = new THREE.Vector3(-tangent.z, 0, tangent.x);
                        
                        // å½“å‰ç‚¹çš„å·¦å³è¾¹ç•Œ
                        const left1 = new THREE.Vector3(
                            point.x + normal.x * PATH_WIDTH / 2,
                            point.y,
                            point.z + normal.z * PATH_WIDTH / 2
                        );
                        const right1 = new THREE.Vector3(
                            point.x - normal.x * PATH_WIDTH / 2,
                            point.y,
                            point.z - normal.z * PATH_WIDTH / 2
                        );
                        
                        // ä¸‹ä¸€ä¸ªç‚¹çš„å·¦å³è¾¹ç•Œ
                        const left2 = new THREE.Vector3(
                            nextPoint.x + normal.x * PATH_WIDTH / 2,
                            nextPoint.y,
                            nextPoint.z + normal.z * PATH_WIDTH / 2
                        );
                        const right2 = new THREE.Vector3(
                            nextPoint.x - normal.x * PATH_WIDTH / 2,
                            nextPoint.y,
                            nextPoint.z - normal.z * PATH_WIDTH / 2
                        );
                        
                        // æ·»åŠ ä¸¤ä¸ªå››è¾¹å½¢ï¼ˆ4ä¸ªä¸‰è§’å½¢ï¼‰
                        vertices.push(
                            // ç¬¬ä¸€ä¸ªä¸‰è§’å½¢
                            left1.x, left1.y, left1.z,
                            right1.x, right1.y, right1.z,
                            left2.x, left2.y, left2.z,
                            
                            // ç¬¬äºŒä¸ªä¸‰è§’å½¢
                            right1.x, right1.y, right1.z,
                            right2.x, right2.y, right2.z,
                            left2.x, left2.y, left2.z
                        );
                    }
                }
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            
            // åˆ›å»ºæè´¨
            const material = new THREE.MeshBasicMaterial({
                color: PATH_COLOR,
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide,
                depthWrite: false // ç®€åŒ–ç‰ˆå¯ä»¥å…³é—­æ·±åº¦å†™å…¥
            });
            
            // åˆ›å»ºç½‘æ ¼
            pathLine = new THREE.Mesh(geometry, material);
            
            // è®¾ç½®æ¸²æŸ“é¡ºåºï¼Œç¡®ä¿åœ¨åœ°é¢ä¸Šæ–¹
            pathLine.renderOrder = 0;
            
            scene.add(pathLine);
            
            // æ·»åŠ å‚ç›´è¿æ¥çº¿
            addVerticalConnectors(path[0], path[path.length - 1]);
            
            console.log("ç®€åŒ–ç‰ˆäºŒç»´è·¯å¾„å¸¦ç»˜åˆ¶å®Œæˆ");
        }   

        

        // ========== æ·»åŠ å‘å…‰è¾¹ç¼˜æ•ˆæœ ==========
        function addGlowEffect(mesh, color) {
            // åˆ›å»ºè¾¹ç¼˜å‡ ä½•ä½“ï¼ˆæ¯”ä¸»è·¯å¾„ç¨å¤§ï¼‰
            const edges = new THREE.EdgesGeometry(mesh.geometry, 1);
            const lineMaterial = new THREE.LineBasicMaterial({
                color: color,
                linewidth: 2,
                transparent: true,
                opacity: 0.9
            });
            
            const edgeLines = new THREE.LineSegments(edges, lineMaterial);
            mesh.add(edgeLines); // ä½œä¸ºå­å¯¹è±¡æ·»åŠ åˆ°è·¯å¾„ç½‘æ ¼
            
            // å­˜å‚¨å¼•ç”¨ï¼Œä»¥ä¾¿åç»­ç§»é™¤
            mesh.userData.edgeLines = edgeLines;
        }

        // ========== æ·»åŠ å‚ç›´è¿æ¥çº¿ ==========
        function addVerticalConnectors(startPoint3D, endPoint3D) {
            // èµ·ç‚¹å‚ç›´è¿æ¥çº¿ï¼ˆä»èµ·ç‚¹æ ‡è®°åˆ°ç½‘æ ¼ï¼‰
            if (startPoint && startPoint.position) {
                const startPoints = [
                    new THREE.Vector3(
                        startPoint.position.x,
                        startPoint.position.y,
                        startPoint.position.z
                    ),
                    new THREE.Vector3(
                        startPoint.position.x,
                        GRID_Y + 0.05,  // ç•¥é«˜äºç½‘æ ¼
                        startPoint.position.z
                    )
                ];
                
                const startGeometry = new THREE.BufferGeometry().setFromPoints(startPoints);
                const startConnector = new THREE.Line(
                    startGeometry,
                    new THREE.LineDashedMaterial({
                        color: 0x4CAF50,
                        dashSize: 0.1,
                        gapSize: 0.05,
                        linewidth: 2
                    })
                );
                startConnector.computeLineDistances();
                scene.add(startConnector);
                
                // 5ç§’åç§»é™¤è¿æ¥çº¿
                setTimeout(() => {
                    scene.remove(startConnector);
                }, 5000);
            }
            
            // ç»ˆç‚¹å‚ç›´è¿æ¥çº¿ï¼ˆä»ç»ˆç‚¹æ ‡è®°åˆ°ç½‘æ ¼ï¼‰
            if (endPoint && endPoint.position) {
                const endPoints = [
                    new THREE.Vector3(
                        endPoint.position.x,
                        endPoint.position.y,
                        endPoint.position.z
                    ),
                    new THREE.Vector3(
                        endPoint.position.x,
                        GRID_Y + 0.05,  // ç•¥é«˜äºç½‘æ ¼
                        endPoint.position.z
                    )
                ];
                
                const endGeometry = new THREE.BufferGeometry().setFromPoints(endPoints);
                const endConnector = new THREE.Line(
                    endGeometry,
                    new THREE.LineDashedMaterial({
                        color: 0xF44336,
                        dashSize: 0.1,
                        gapSize: 0.05,
                        linewidth: 2
                    })
                );
                endConnector.computeLineDistances();
                scene.add(endConnector);
                
                // 5ç§’åç§»é™¤è¿æ¥çº¿
                setTimeout(() => {
                    scene.remove(endConnector);
                }, 5000);
            }
        }

        // ========== æ›´æ–°è·¯å¾„ä¿¡æ¯UI ==========
        // ========== æ›´æ–°è·¯å¾„ä¿¡æ¯UI ==========
        function updatePathInfo(length) {
            const element = document.getElementById('pathInfo');
            
            if (length > 0) {
                element.textContent = `è·¯å¾„: å·²è®¡ç®— (${length.toFixed(1)}ç±³)`;
                element.style.borderLeftColor = '#2196F3';
                element.style.color = '#1976D2';
                
                // æ·»åŠ è·¯å¾„ç»†èŠ‚æ˜¾ç¤º
                if (!document.getElementById('pathDetails')) {
                    const details = document.createElement('div');
                    details.id = 'pathDetails';
                    details.className = 'path-details';
                    //details.textContent = `ç‚¹å‡»è·¯å¾„å¯æŸ¥çœ‹è¯¦æƒ…`;
                    //element.parentNode.appendChild(details);
                }
            } else {
                element.textContent = 'è·¯å¾„: æœªè®¡ç®—æˆ–æœªæ‰¾åˆ°è·¯å¾„';
                element.style.borderLeftColor = '';
                element.style.color = '';
                
                const details = document.getElementById('pathDetails');
                if (details) {
                    details.parentNode.removeChild(details);
                }
            }
        }

            //floor.glbæ–‡ä»¶ä¸ºåœ°æ¿(21.0m*17.0m*0.01m)ï¼ŒåŸç‚¹åœ¨è§’è½ï¼Œx-8.5,y-0.01,z+9.5æ˜¯ä¿®æ­£åˆ°ä¸­å¿ƒçš„åæ ‡
            loader.load('./3D model/floor.glb', (gltf) => {
            const model = gltf.scene;
            model.position.set(-8.5, -0.01, +9.5);
            scene.add(model);
            onModelLoaded(); // æ·»åŠ è¿™è¡Œ
            });
            //door.glbæ–‡ä»¶ä¸ºå¤§é—¨(2.0m*2.1m*0.8m)ï¼ŒåŸç‚¹åœ¨è§’è½ï¼Œx-1,z+0.02æ˜¯ä¿®æ­£åˆ°ä¸­å¿ƒçš„åæ ‡
            // åœ¨å¤§é—¨æ¨¡å‹åŠ è½½åè°ƒç”¨
            // åœ¨door.glbåŠ è½½å›è°ƒä¸­æ·»åŠ 
            loader.load('./3D model/door.glb', (gltf) => {
                const model = gltf.scene;
                model.position.set(0.5-1, 0, -11.5+0.02);
                scene.add(model);
                
                createDoorSign();
                createDoorClickableLayers(); // æ–°å¢è¿™è¡Œ
                onModelLoaded(); // æ·»åŠ è¿™è¡Œ
            });
            loader.load('./3D model/outer.glb', (gltf) => {
                const model = gltf.scene;
                model.position.set(0, 0, 0);
                model.rotation.y = Math.PI;
                scene.add(model);
                onModelLoaded(); // æ·»åŠ è¿™è¡Œ
            });                  
            // åŠ è½½ GLB åéå†æ‰€æœ‰æ¨¡å‹ï¼Œç»Ÿä¸€æè´¨
            loader.load('./3D model/outerworld.glb', (gltf) => {
            gltf.scene.traverse((node) => {
                if (node.isMesh && node.material) {
                // 1. å¼ºåˆ¶åŒé¢æ¸²æŸ“ï¼Œé¿å…æ³•çº¿é”™è¯¯å¯¼è‡´çš„é»‘é¢
                node.material.side = THREE.DoubleSide;
                
                // 2. ç»Ÿä¸€ç²—ç³™åº¦å’Œé‡‘å±åº¦ï¼Œè®©æ‰€æœ‰è¡¨é¢åå°„ä¸€è‡´
                node.material.roughness = 0.6; // é™ä½ç²—ç³™åº¦ï¼Œè®©è¡¨é¢æ›´äº®
                node.material.metalness = 0.1;
                
                // 3. ç¡®ä¿æè´¨æ›´æ–°ç”Ÿæ•ˆ
                node.material.needsUpdate = true;
                }
            });
            const model = gltf.scene;
            model.position.set(0, 0, 0);
            model.rotation.y = Math.PI;
            scene.add(model);
            onModelLoaded(); // æ·»åŠ è¿™è¡Œ
            });
            //communication_zone.glbæ–‡ä»¶ä¸ºäº¤æµåŒºçš„ä¸€ä¸ªå•ä½“(4.8m*0.8m*3.9m)ï¼ŒåŸç‚¹åœ¨è§’è½ï¼Œx+2.4,z-1.5æ˜¯ä¿®æ­£åˆ°ä¸­å¿ƒçš„åæ ‡
            loader.load('./3D model/communication_zone.glb', (gltf) => {
            const model = gltf.scene;
            // åŸå§‹modelæ—‹è½¬180åº¦ï¼ˆç»•Yè½´ï¼Œä¹Ÿå¯ä»¥æ ¹æ®éœ€è¦ç»•Xæˆ–Zè½´ï¼‰
            model.rotation.y = Math.PI; // 180åº¦ç­‰äºMath.PIå¼§åº¦
            model.position.set(4.5+2.4, 0, -3.9-1.5);
            scene.add(model);

            // åˆ›å»ºç‹¬ç«‹çš„cloneï¼Œä¸ç»§æ‰¿æ—‹è½¬
            //å…‹éš†ä½“ä¸æ—‹è½¬ä¿®æ­£åˆ°ä¸­å¿ƒçš„åæ ‡ä¸ºx-2.4,z+1.5
            const clone = model.clone();
            // é‡ç½®cloneçš„æ—‹è½¬ï¼ˆå¯é€‰ï¼Œæ ¹æ®éœ€æ±‚ï¼‰
            clone.rotation.y = Math.PI;
            clone.position.set(4.5-2.4, 0, -8+1.5);
            scene.add(clone);
            onModelLoaded(); // æ·»åŠ è¿™è¡Œ
            });
            //table_chairs.glbæ–‡ä»¶æ˜¯é˜…è§ˆåŒºçš„æ¡Œæ¤…ï¼ŒåŸç‚¹åœ¨è§’è½ï¼Œx-1ã€z+1.15æ˜¯ä¿®æ­£åˆ°ä¸­å¿ƒçš„åæ ‡
            loader.load('./3D model/table_chairs.glb', (gltf) => {
            const model = gltf.scene;
            const positions = [
                [-6-1, 0, -3.5+1.15], // åŸå§‹æ¨¡å‹ä½ç½®
                [-2-1, 0, -3.5+1.15], // å…‹éš†1
                [-2-1, 0, -7.5+1.15], // å…‹éš†2
                [-6-1, 0, -7.5+1.15]  // å…‹éš†3
            ];

            positions.forEach((pos, index) => {
                const instance = index === 0 ? model : model.clone();
                instance.position.set(...pos);
                scene.add(instance);
            });
            onModelLoaded(); // æ·»åŠ è¿™è¡Œ
            });
            //bookshelf.glbçš„æ–‡ä»¶æ˜¯ä¹¦æ¶ï¼ˆ3.0m*2.0m*1.0mï¼‰åŸç‚¹åœ¨å‡ ä½•ä¸­å¿ƒï¼Œä¹¦æ¶çš„yåæ ‡éœ€è¦ä¿®æ­£+1ï¼Œæ‰èƒ½è½¬æ¢åˆ°åº•é¢ä¸­å¿ƒ
            loader.load('./3D model/bookshelf.glb', (gltf) => {
            const model = gltf.scene;
            model.position.set(0, +1, 0.5);
            // åˆ›å»ºä¹¦æ¶æ ‡ç­¾
            createBookshelfLabels();
            // åˆ›å»ºä¸»ç½‘æ ¼ä¹¦æ¶ç‚¹å‡»åŒºåŸŸ
            for(let z = 0; z < 4; z++) {
                const xOffsets = [-5, 0, 5];
                xOffsets.forEach((x, colIndex) => {
                    const clone = model.clone();
                    clone.position.set(x, 1, 0.5 + z * 2);
                    
                    // ä¸ºè¿™ä¸ªä¹¦æ¶åˆ›å»ºç‚¹å‡»åŒºåŸŸ
                    createShelfClickableLayers(clone, (z * 3 + colIndex) + 1);
                    shelves.push(clone);
                    
                    scene.add(clone);
                });
            }

            // ä¿®æ”¹ç‰¹æ®Šä½ç½®ä¹¦æ¶çš„è°ƒç”¨ï¼š
            const specialPoints = [
                {x: -4, y: +1, z: -3.5, index: 13},
                {x: -4, y: +1, z: -7.5, index: 14}
            ];

            specialPoints.forEach(point => {
                const clone = model.clone();
                clone.position.set(point.x, point.y, point.z);
                clone.rotation.y = -Math.PI / 2; // 90åº¦
                
                // ä¸ºè¿™ä¸ªä¹¦æ¶åˆ›å»ºç‚¹å‡»åŒºåŸŸï¼ˆæ—‹è½¬90åº¦ï¼‰
                createShelfClickableLayers(clone, point.index, true);
                shelves.push(clone);
                
                scene.add(clone);
            });
                onModelLoaded(); // æ·»åŠ è¿™è¡Œ
        });

    // ========== åˆ›å»ºé€æ˜ç»ç’ƒå›´å¢™ ==========
    function createGlassWall() {
        // ç»ç’ƒæè´¨
        const glassMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x88ccff,      // æ·¡è“è‰²
            transparent: true,
            opacity: 0.2,         // éå¸¸é€æ˜
            roughness: 0.05,      // å…‰æ»‘
            metalness: 0.0,
            transmission: 0.95,   // é«˜é€å…‰æ€§
            thickness: 0.1,       // ç»ç’ƒåšåº¦
            side: THREE.DoubleSide // åŒé¢æ¸²æŸ“
        });
        
        const wallHeight = 1.2;   // å›´å¢™é«˜åº¦1.2ç±³
        const wallThickness = 0.05; // å›´å¢™åšåº¦5å˜ç±³
        
        // åˆ›å»ºå›´å¢™å‡½æ•°
        function createWallSegment(startX, startZ, endX, endZ) {
            // è®¡ç®—å¢™çš„é•¿åº¦
            const length = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endZ - startZ, 2));
            
            // åˆ›å»ºå¢™çš„å‡ ä½•ä½“
            const geometry = new THREE.BoxGeometry(length, wallHeight, wallThickness);
            const wall = new THREE.Mesh(geometry, glassMaterial);
            
            // è®¡ç®—å¢™çš„ä¸­å¿ƒä½ç½®
            const centerX = (startX + endX) / 2;
            const centerZ = (startZ + endZ) / 2;
            
            // è®¾ç½®å¢™çš„ä½ç½®ï¼ˆYåæ ‡ä»åœ°é¢å¼€å§‹ï¼‰
            wall.position.set(centerX, wallHeight / 2, centerZ);
            
            // è®¡ç®—æ—‹è½¬è§’åº¦ï¼ˆä½¿å¢™æ²¿ç€ä¸¤ç‚¹è¿çº¿æ–¹å‘ï¼‰
            const angle = Math.atan2(endZ - startZ, endX - startX);
            wall.rotation.y = -angle; // è´Ÿå·æ˜¯å› ä¸ºThree.jsçš„åæ ‡ç³»
            
            return wall;
        }
        
        // å®šä¹‰å››è¾¹å›´å¢™çš„åæ ‡ï¼ˆå¤§é—¨å¤„ç•™å‡ºç¼ºå£ï¼‰
        // åŒ—å¢™ (Z=9.5)
        const northWall = createWallSegment(-8.5, 9.5, 8.5, 9.5);
        scene.add(northWall);
        
        // å—å¢™ (Z=-11.5)ï¼Œåˆ†ä¸¤æ®µé¿å¼€å¤§é—¨
        // å·¦æ®µï¼šä»(-8.5, -11.5)åˆ°(-1.5, -11.5)
        const southWallLeft = createWallSegment(-8.5, -11.5, -0.5, -11.5);
        scene.add(southWallLeft);
        
        // å³æ®µï¼šä»(0.5, -11.5)åˆ°(8.5, -11.5)
        const southWallRight = createWallSegment(1.5, -11.5, 8.5, -11.5);
        scene.add(southWallRight);
        
        // è¥¿å¢™ (X=-8.5)
        const westWall = createWallSegment(-8.5, -11.5, -8.5, 9.5);
        scene.add(westWall);
        
        // ä¸œå¢™ (X=8.5)
        const eastWall = createWallSegment(8.5, -11.5, 8.5, 9.5);
        scene.add(eastWall);
        
        // æ·»åŠ å›´å¢™é¡¶éƒ¨è£…é¥°çº¿
        createWallTopEdging();
        
        console.log("é€æ˜ç»ç’ƒå›´å¢™å·²åˆ›å»ºå®Œæˆ");
    }
    createGlassWall();

    // ========== åˆ›å»ºå›´å¢™é¡¶éƒ¨è£…é¥°çº¿ ==========
    function createWallTopEdging() {
        // é‡‘å±è£…é¥°çº¿æè´¨
        const metalMaterial = new THREE.MeshStandardMaterial({
            color: 0xcccccc,      // æµ…ç°è‰²
            roughness: 0.3,
            metalness: 0.8
        });
        
        const edgingHeight = 0.05;   // è£…é¥°çº¿é«˜åº¦5å˜ç±³
        const edgingThickness = 0.06; // è£…é¥°çº¿åšåº¦6å˜ç±³ï¼ˆæ¯”å›´å¢™ç•¥åšï¼‰
        
        // åˆ›å»ºè£…é¥°çº¿å‡½æ•°ï¼ˆä¸åˆ›å»ºå¢™ç±»ä¼¼ä½†æ›´ç»†ï¼‰
        function createEdgingSegment(startX, startZ, endX, endZ) {
            const length = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endZ - startZ, 2));
            const geometry = new THREE.BoxGeometry(length, edgingHeight, edgingThickness);
            const edging = new THREE.Mesh(geometry, metalMaterial);
            
            const centerX = (startX + endX) / 2;
            const centerZ = (startZ + endZ) / 2;
            
            // æ”¾ç½®åœ¨å›´å¢™é¡¶éƒ¨ï¼Œæ¯”å›´å¢™é«˜åŠä¸ªè£…é¥°çº¿é«˜åº¦
            edging.position.set(centerX, 1.2 + edgingHeight / 2, centerZ);
            
            const angle = Math.atan2(endZ - startZ, endX - startX);
            edging.rotation.y = -angle;
            
            return edging;
        }
        
        // æ·»åŠ å››è¾¹çš„è£…é¥°çº¿
        scene.add(createEdgingSegment(-8.5, 9.5, 8.5, 9.5));           // åŒ—å¢™é¡¶éƒ¨
        scene.add(createEdgingSegment(-8.5, -11.5, -0.5, -11.5));      // å—å¢™å·¦æ®µé¡¶éƒ¨
        scene.add(createEdgingSegment(1.5, -11.5, 8.5, -11.5));        // å—å¢™å³æ®µé¡¶éƒ¨
        scene.add(createEdgingSegment(-8.5, -11.5, -8.5, 9.5));        // è¥¿å¢™é¡¶éƒ¨
        scene.add(createEdgingSegment(8.5, -11.5, 8.5, 9.5));          // ä¸œå¢™é¡¶éƒ¨
    }
    createWallTopEdging();

    // ========== åˆ›å»ºå¤§é—¨æ ‡è¯†ç‰Œ ==========
    function createDoorSign() {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        
        // è®¾ç½®ç”»å¸ƒå¤§å°
        canvas.width = 256;
        canvas.height = 128;
        
        // ç»˜åˆ¶èƒŒæ™¯
        context.fillStyle = 'rgba(255, 255, 200, 0.9)'; // æ·¡é»„è‰²åŠé€æ˜èƒŒæ™¯
        context.fillRect(0, 0, canvas.width, canvas.height);
        
        // ç»˜åˆ¶è¾¹æ¡†
        context.strokeStyle = '#8B4513'; // æ£•è‰²è¾¹æ¡†
        context.lineWidth = 4;
        context.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
        
        // ç»˜åˆ¶æ–‡å­—
        context.font = 'bold 48px Arial';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillStyle = '#8B0000'; // æ·±çº¢è‰²æ–‡å­—
        context.fillText('å¤§é—¨', canvas.width / 2, canvas.height / 2);
        
        // åˆ›å»ºçº¹ç†
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        
        // åˆ›å»ºç²¾çµæè´¨
        const spriteMaterial = new THREE.SpriteMaterial({
            map: texture,
            transparent: true,
            opacity: 0.9
        });
        
        // åˆ›å»ºç²¾çµ
        const sign = new THREE.Sprite(spriteMaterial);
        
        // è®¾ç½®ç²¾çµå¤§å°å’Œä½ç½®
        sign.scale.set(2, 1, 1); // å®½é«˜æ¯”2:1
        sign.position.set(0.5, 2.6, -11.3); // åœ¨é—¨æ¡†ä¸Šæ–¹
        
        scene.add(sign);
        
        // ä½¿æ ‡è¯†ç‰Œå§‹ç»ˆé¢å‘ç›¸æœº
        sign.lookAt(camera.position);
    }


    // ========== åˆ›å»ºæ–‡å­—ç²¾çµå‡½æ•° ==========
    function createTextSprite(text, color = 0xffff00, bgColor = 0x000000, fontSize = 0.5) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        
        // è®¾ç½®ç”»å¸ƒå¤§å°
        const textHeight = 128;
        canvas.width = text.length * 100;
        canvas.height = textHeight;
        
        // ç»˜åˆ¶èƒŒæ™¯
        context.fillStyle = `rgba(${bgColor >> 16}, ${(bgColor >> 8) & 0xff}, ${bgColor & 0xff}, 0.8)`;
        context.fillRect(0, 0, canvas.width, canvas.height);
        
        // ç»˜åˆ¶æ–‡å­—
        context.font = `bold ${textHeight * 0.8}px Arial`;
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillStyle = `rgb(${color >> 16}, ${(color >> 8) & 0xff}, ${color & 0xff})`;
        context.fillText(text, canvas.width / 2, canvas.height / 2);
        
        // åˆ›å»ºçº¹ç†
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        
        // åˆ›å»ºç²¾çµæè´¨
        const spriteMaterial = new THREE.SpriteMaterial({
            map: texture,
            transparent: true,
            opacity: 0.9,
            depthTest: false  // æ€»æ˜¯æ˜¾ç¤ºåœ¨æœ€å‰é¢
        });
        
        // åˆ›å»ºç²¾çµ
        const sprite = new THREE.Sprite(spriteMaterial);
        
        // è®¾ç½®ç²¾çµå¤§å°
        const scale = fontSize;
        sprite.scale.set(canvas.width / canvas.height * scale, scale, 1);
        
        return sprite;
    }

    // ========== åˆ›å»ºä¹¦æ¶æ ‡ç­¾ ==========
    function createBookshelfLabels() {
        const labels = [];
        
        // ä¸»ç½‘æ ¼ä¹¦æ¶æ ‡ç­¾ (1-12å·)
        let labelIndex = 1;
        for(let z = 0; z < 4; z++) {
            const xOffsets = [-5, 0, 5];
            xOffsets.forEach(x => {
                // åˆ›å»ºæ–‡å­—ç²¾çµ
                const label = createTextSprite(
                    `ä¹¦æ¶${labelIndex}`,
                    0x00ff00,  // ç»¿è‰²æ–‡å­—
                    0x000000,  // é»‘è‰²èƒŒæ™¯
                    0.3        // è¾ƒå°å­—ä½“
                );
                
                // è®¾ç½®ä½ç½®ï¼šä¹¦æ¶åº•é¢ä¸­å¿ƒ + ä¹¦æ¶é«˜åº¦(2m) + ç¨å¾®å‘ä¸Šåç§»
                label.position.set(x, 2.5, 0.5 + z * 2);
                
                // æ·»åŠ åˆ°åœºæ™¯
                scene.add(label);
                labels.push(label);
                
                labelIndex++;
            });
        }
        
        // ç‰¹æ®Šä½ç½®ä¹¦æ¶æ ‡ç­¾ (13-14å·)
        const specialPoints = [
            {x: -4, z: -3.5, index: 13},
            {x: -4, z: -7.5, index: 14}
        ];
        
        specialPoints.forEach(point => {
            const label = createTextSprite(
                `ä¹¦æ¶${point.index}`,
                0x00ff00,
                0x000000,
                0.3
            );
            
            label.position.set(point.x, 2.5, point.z);
            scene.add(label);
            labels.push(label);
        });
        
        return labels;
    }

    // ========== åˆ›å»ºå¤§é—¨æ ‡ç­¾ ==========
    function createDoorLabel() {
        // åˆ›å»ºå¤§é—¨æ ‡ç­¾ï¼ˆæ›´æ˜¾çœ¼ï¼‰
        const doorLabel = createTextSprite(
            "å¤§é—¨å…¥å£",
            0xff0000,    // çº¢è‰²æ–‡å­—ï¼Œæ›´é†’ç›®
            0xffff00,    // é»„è‰²èƒŒæ™¯ï¼Œæ›´çªå‡º
            0.5          // æ›´å¤§å­—ä½“
        );
        
        // è®¾ç½®ä½ç½®ï¼šå¤§é—¨åº•é¢ä¸­å¿ƒ + é—¨é«˜åº¦(2.1m) + ç¨å¾®å‘ä¸Šåç§»
        doorLabel.position.set(0.5, 2.6, -11.5+0.02);
        
        scene.add(doorLabel);
        return doorLabel;
    }

    // ========== åˆ›å»ºä¹¦æ¶å¯ç‚¹å‡»å±‚ ==========
    function createShelfClickableLayers(shelf, shelfIndex, isRotated = false) {
        const columns = SHELF_PARAMS.columns;
        const rows = SHELF_PARAMS.rows;
        
        // è·å–ä¹¦æ¶çš„æ—‹è½¬è§’åº¦
        const shelfRotation = isRotated ? Math.PI / 2 : 0;
        
        // åˆ›å»ºæ­£é¢ç‚¹å‡»åŒºåŸŸ
        for (let col = 0; col < columns; col++) {
            for (let row = 0; row < rows; row++) {
                // æ­£é¢ç‚¹å‡»å±‚
                createClickableLayer(shelf, shelfIndex, col, row, 'back', shelfRotation);
                
                // èƒŒé¢ç‚¹å‡»å±‚
                createClickableLayer(shelf, shelfIndex, col, row, 'front', shelfRotation);
            }
        }
    }

    // ========== åˆ›å»ºå•ä¸ªç‚¹å‡»å±‚ ==========
    function createClickableLayer(shelf, shelfIndex, column, row, face, shelfRotation = 0) {
        // è®¡ç®—å±‚åœ¨ä¹¦æ¶å±€éƒ¨åæ ‡ç³»ä¸­çš„ä½ç½®ï¼ˆä¹¦æ¶æœªæ—‹è½¬æ—¶çš„ä½ç½®ï¼‰
        const localX = (column - (SHELF_PARAMS.columns-1)/2) * SHELF_PARAMS.columnWidth;
        const localY = (row - (SHELF_PARAMS.rows-1)/2) * SHELF_PARAMS.rowHeight;
        
        // æ ¹æ®æ­£é¢/èƒŒé¢è®¾ç½®Zåæ ‡
        let localZ;
        let layerRotationY = 0; // ç‚¹å‡»å±‚è‡ªèº«çš„æ—‹è½¬
        
        if (face === 'back') {
            localZ = SHELF_PARAMS.depth / 2 + SHELF_PARAMS.frontOffset;
            // æ­£é¢æœå‘å¤–éƒ¨
            layerRotationY = 0;
        } else { // 'front'
            localZ = -SHELF_PARAMS.depth / 2 + SHELF_PARAMS.backOffset;
            // èƒŒé¢æœå‘å¤–éƒ¨ï¼Œéœ€è¦æ—‹è½¬180åº¦
            layerRotationY = Math.PI;
        }
        
        // åˆ›å»ºé€æ˜ç‚¹å‡»å¹³é¢
        const geometry = new THREE.PlaneGeometry(
            SHELF_PARAMS.columnWidth * 0.99,  // ç¨å¾®ç¼©å°é¿å…é‡å 
            SHELF_PARAMS.rowHeight * 0.99
        );
        const material = new THREE.MeshBasicMaterial({
            color: 0x000000,
            transparent: true,
            opacity: 0.0,  // å®Œå…¨é€æ˜ï¼Œä¸å¯è§
            side: THREE.DoubleSide
        });
        
        const clickableLayer = new THREE.Mesh(geometry, material);
        
        // è®¾ç½®ç‚¹å‡»å±‚çš„ä½ç½®ï¼ˆå±€éƒ¨åæ ‡ç³»ï¼‰
        clickableLayer.position.set(localX, localY, localZ);
        
        // è®¾ç½®ç‚¹å‡»å±‚çš„æ—‹è½¬ï¼šå…ˆåº”ç”¨å±‚è‡ªèº«çš„æ—‹è½¬ï¼Œç„¶ååŠ ä¸Šä¹¦æ¶çš„æ—‹è½¬
        clickableLayer.rotation.y = layerRotationY;
        
        // å­˜å‚¨ç‚¹å‡»å±‚ä¿¡æ¯
        clickableLayer.userData = {
            isShelfLayer: true,
            shelfIndex: shelfIndex,
            column: column + 1,  // åˆ—å·ä»1å¼€å§‹
            row: row + 1,        // å±‚å·ä»1å¼€å§‹
            face: face,
            shelfRotation: shelfRotation,
            shelf: shelf,
            localPosition: new THREE.Vector3(localX, localY, localZ)
        };
        
        // æ·»åŠ åˆ°ä¹¦æ¶
        shelf.add(clickableLayer);
        clickableLayers.push(clickableLayer);
    }

    function createDoorClickableLayers() {
        // é—¨å¤–ä¾§åˆ¤å®šé¢ (æœå—ï¼Œé¢å‘å¤–éƒ¨)
        const outsideLayer = createDoorPlane('outside');
        
        // é—¨å†…ä¾§åˆ¤å®šé¢ (æœåŒ—ï¼Œé¢å‘å›¾ä¹¦é¦†å†…éƒ¨)
        const insideLayer = createDoorPlane('inside');
        
        // æ·»åŠ åˆ°åœºæ™¯å’Œå…¨å±€æ£€æµ‹æ•°ç»„
        scene.add(outsideLayer, insideLayer);
        clickableLayers.push(outsideLayer, insideLayer);
        doorLayers.push(outsideLayer, insideLayer);
        
        console.log("å¤§é—¨åˆ¤å®šé¢åˆ›å»ºå®Œæˆï¼šå¤–ä¾§å’Œå†…ä¾§");
    }

    function createDoorPlane(face) {
        const geometry = new THREE.PlaneGeometry(DOOR_PARAMS.width, DOOR_PARAMS.height);
        const material = new THREE.MeshBasicMaterial({
            color: 0x0000ff,
            transparent: true,
            opacity: 0.0,
            side: THREE.DoubleSide
        });
        
        const plane = new THREE.Mesh(geometry, material);
        
        // ä½¿ç”¨ä½ çš„Zè½´åç§»å»ºè®®
        const zOffset = face === 'outside' ? -0.01 : 0.07;
        
        plane.position.set(
            DOOR_PARAMS.centerX,
            DOOR_PARAMS.centerY,
            DOOR_PARAMS.centerZ + zOffset
        );
        
        // é—¨å¤–ä¾§æœå—ï¼Œé—¨å†…ä¾§æœåŒ—
        plane.rotation.y = face === 'outside' ? Math.PI : 0;
        
        // ç»Ÿä¸€ç”¨æˆ·æ•°æ®ï¼Œä¸å†åŒºåˆ†å†…å¤–ä¾§æ˜¾ç¤º
        plane.userData = {
            isShelfLayer: true,
            isDoor: true,
            doorFace: face,        // å†…éƒ¨è®°å½•ï¼Œä¸å¯¹å¤–æ˜¾ç¤º
            name: 'å¤§é—¨',          // ç»Ÿä¸€æ˜¾ç¤ºä¸º"å¤§é—¨"
            position: DOOR_UNIFIED_POSITION, // ä½¿ç”¨ç»Ÿä¸€ä½ç½®
            faceChinese: 'å¤§é—¨'    // ç»Ÿä¸€ä¸­æ–‡æ˜¾ç¤º
        };
        
        return plane;
    }

    function createDoorClickableLayers() {
        const outsideLayer = createDoorPlane('outside');
        const insideLayer = createDoorPlane('inside');
        
        scene.add(outsideLayer, insideLayer);
        clickableLayers.push(outsideLayer, insideLayer);
        doorLayers.push(outsideLayer, insideLayer);
    }

            // ========== é¼ æ ‡ç‚¹å‡»äº‹ä»¶å¤„ç† ==========
    renderer.domElement.addEventListener('click', onMouseClick, false);

    function onMouseClick(event) {
        if (!isSettingStart && !isSettingEnd) return;
        
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(clickableLayers);
        
        if (intersects.length > 0) {
            const clickedLayer = intersects[0].object;
            const layerData = clickedLayer.userData;
            
            if (layerData.isDoor) {
                // å¤§é—¨å¤„ç† - ç°åœ¨éƒ½æ˜¾ç¤ºä¸º"å¤§é—¨"
                if (isSettingStart) {
                    setDoorStartPoint(layerData, clickedLayer);
                } else if (isSettingEnd) {
                    setDoorEndPoint(layerData, clickedLayer);
                }
            } else {
                // ä¹¦æ¶å¤„ç†
                if (isSettingStart) {
                    setStartPoint(layerData, clickedLayer);
                } else if (isSettingEnd) {
                    setEndPoint(layerData, clickedLayer);
                }
            }
            
            // æç¤ºä¿¡æ¯ä¹Ÿç»Ÿä¸€ä¸º"å¤§é—¨"
            let message = '';
            if (layerData.isDoor) {
                message = 'å·²é€‰æ‹©å¤§é—¨';  // ä¸å†æ˜¾ç¤ºå†…å¤–ä¾§
            } else {
                const faceText = layerData.face === 'back' ? 'èƒŒé¢' : 'æ­£é¢';
                message = `å·²é€‰æ‹©ä¹¦æ¶${layerData.shelfIndex} ${faceText} ç¬¬${layerData.column}åˆ—ç¬¬${layerData.row}å±‚`;
            }
            
            showClickHint(message);
        }
    }

    // ========== è®¾ç½®èµ·ç‚¹ ==========
    window.setStartPoint = function(layerData, clickedLayer) {  // æ·»åŠ clickedLayerå‚æ•°
        // ç§»é™¤æ—§çš„èµ·ç‚¹æ ‡è®°
        if (startMarker) {
            scene.remove(startMarker);
        }
        
        // åˆ›å»ºèµ·ç‚¹æ ‡è®°ï¼ˆç»¿è‰²å°çƒï¼‰
        const geometry = new THREE.SphereGeometry(0.15, 16, 16);
        const material = new THREE.MeshLambertMaterial({ 
            color: 0x4CAF50,
            emissive: 0x2E7D32,
            emissiveIntensity: 2.5
        });
        startMarker = new THREE.Mesh(geometry, material);
        
        // è®¡ç®—æ ‡è®°ä½ç½®ï¼ˆä½¿ç”¨æ–°çš„calculateMarkerPositionå‡½æ•°ï¼‰
        const markerPosition = calculateMarkerPosition(layerData, clickedLayer);  // ä¼ é€’clickedLayer
        startMarker.position.copy(markerPosition);
        
        scene.add(startMarker);
        
        // å­˜å‚¨èµ·ç‚¹ä¿¡æ¯
        startPoint = {
            shelfIndex: layerData.shelfIndex,
            column: layerData.column,
            row: layerData.row,
            face: layerData.face,
            position: markerPosition.clone()
        };
        
        // æ›´æ–°UIæ˜¾ç¤º
        updateStartInfo();
        
        // é€€å‡ºè®¾ç½®æ¨¡å¼
        isSettingStart = false;
        document.getElementById('startBtn').classList.remove('active');
        // æ›´æ–°é˜…è§ˆåŒºæ ‡è®°ï¼ˆå› ä¸ºèµ·ç‚¹å¯èƒ½æ”¹å˜é˜…è§ˆåŒºçš„é€šè¡ŒçŠ¶æ€ï¼‰
        if (startPoint || endPoint) {
            markReadingArea();
        }
    }

    // ========== è®¾ç½®ç»ˆç‚¹ ==========
    window.setEndPoint = function(layerData, clickedLayer) {  // æ·»åŠ clickedLayerå‚æ•°
        // ç§»é™¤æ—§çš„ç»ˆç‚¹æ ‡è®°
        if (endMarker) {
            scene.remove(endMarker);
        }
        
        // åˆ›å»ºç»ˆç‚¹æ ‡è®°ï¼ˆçº¢è‰²å°çƒï¼‰
        const geometry = new THREE.SphereGeometry(0.15, 16, 16);
        const material = new THREE.MeshLambertMaterial({ 
            color: 0xFF4336,
            emissive: 0xC62828,
            emissiveIntensity: 2.5
        });
        endMarker = new THREE.Mesh(geometry, material);
        
        // è®¡ç®—æ ‡è®°ä½ç½®
        const markerPosition = calculateMarkerPosition(layerData, clickedLayer);  // ä¼ é€’clickedLayer
        endMarker.position.copy(markerPosition);
        endMarker.rotation.x = Math.PI; // ä½¿é”¥ä½“æœä¸Š
        
        scene.add(endMarker);
        
        // å­˜å‚¨ç»ˆç‚¹ä¿¡æ¯
        endPoint = {
            shelfIndex: layerData.shelfIndex,
            column: layerData.column,
            row: layerData.row,
            face: layerData.face,
            position: markerPosition.clone()
        };


        
        // æ›´æ–°UIæ˜¾ç¤º
        updateEndInfo();
        
        // é€€å‡ºè®¾ç½®æ¨¡å¼
        isSettingEnd = false;
        document.getElementById('endBtn').classList.remove('active');
        // æ›´æ–°é˜…è§ˆåŒºæ ‡è®°ï¼ˆå› ä¸ºèµ·ç‚¹å¯èƒ½æ”¹å˜é˜…è§ˆåŒºçš„é€šè¡ŒçŠ¶æ€ï¼‰
        if (startPoint || endPoint) {
            markReadingArea();
        }
    }

    window.setDoorStartPoint = function(layerData, clickedLayer) {
        // ç§»é™¤æ—§çš„èµ·ç‚¹æ ‡è®°
        if (startMarker) {
            scene.remove(startMarker);
        }
        
        // åˆ›å»ºç»¿è‰²æ ‡è®°åœ†é”¥
        const geometry = new THREE.ConeGeometry(0.3, -0.8, 16);
        const material = new THREE.MeshLambertMaterial({ 
            color: 0x4CAF50,
            emissive: 0x2E7D32,
            emissiveIntensity: 2.5
        });
        startMarker = new THREE.Mesh(geometry, material);
        
        // ğŸ¯ å…³é”®ä¿®æ”¹ï¼šå°†æ ‡è®°æ”¾åœ¨å¤§é—¨ç²¾çµçš„æ­£ä¸Šæ–¹
        // ä½¿ç”¨ç»Ÿä¸€çš„å¤§é—¨ä½ç½®ï¼ŒYè½´åŠ 0.3ç±³ï¼ˆæ”¾åœ¨ç²¾çµä¸Šæ–¹ï¼‰
        const markerPos = new THREE.Vector3(
            DOOR_UNIFIED_POSITION.x,
            DOOR_UNIFIED_POSITION.y + 0.8,  // åœ¨ç²¾çµä¸Šæ–¹0.3ç±³
            DOOR_UNIFIED_POSITION.z
        );
        
        startMarker.position.copy(markerPos);
        scene.add(startMarker);
        
        // å­˜å‚¨ç»Ÿä¸€çš„èµ·ç‚¹ä¿¡æ¯
        startPoint = {
            isDoor: true,
            doorFace: layerData.doorFace,  // å†…éƒ¨è®°å½•ç‚¹å‡»äº†å“ªä¸€ä¾§
            name: 'å¤§é—¨',
            position: markerPos.clone(),
            faceChinese: 'å¤§é—¨'  // ç»Ÿä¸€æ˜¾ç¤º
        };
        
        // æ›´æ–°UI
        updateStartInfo();
        isSettingStart = false;
        document.getElementById('startBtn').classList.remove('active');
    }

    window.setDoorEndPoint = function(layerData, clickedLayer) {
        // ç§»é™¤æ—§çš„ç»ˆç‚¹æ ‡è®°
        if (endMarker) {
            scene.remove(endMarker);
        }
        
        // åˆ›å»ºçº¢è‰²æ ‡è®°åœ†é”¥
        const geometry = new THREE.ConeGeometry(0.3, -0.8, 16);
        const material = new THREE.MeshLambertMaterial({ 
            color: 0xF44336,
            emissive: 0xC62828,
            emissiveIntensity: 2.5
        });
        endMarker = new THREE.Mesh(geometry, material);
        
        // ğŸ¯ åŒæ ·çš„ä½ç½®ï¼šå¤§é—¨ç²¾çµæ­£ä¸Šæ–¹
        const markerPos = new THREE.Vector3(
            DOOR_UNIFIED_POSITION.x,
            DOOR_UNIFIED_POSITION.y + 0.8,  // åœ¨ç²¾çµä¸Šæ–¹0.3ç±³
            DOOR_UNIFIED_POSITION.z
        );
        
        endMarker.position.copy(markerPos);
        scene.add(endMarker);
        
        // å­˜å‚¨ç»Ÿä¸€çš„ç»ˆç‚¹ä¿¡æ¯
        endPoint = {
            isDoor: true,
            doorFace: layerData.doorFace,  // å†…éƒ¨è®°å½•ç‚¹å‡»äº†å“ªä¸€ä¾§
            name: 'å¤§é—¨',
            position: markerPos.clone(),
            faceChinese: 'å¤§é—¨'  // ç»Ÿä¸€æ˜¾ç¤º
        };
        
        updateEndInfo();
        isSettingEnd = false;
        document.getElementById('endBtn').classList.remove('active');
    }
    // ========== è®¡ç®—æ ‡è®°ä½ç½® ==========
    function calculateMarkerPosition(layerData, clickedLayer) {  // æ·»åŠ clickedLayerå‚æ•°
        // è·å–ç‚¹å‡»å±‚çš„ä¸–ç•Œä½ç½®
        const layerWorldPos = new THREE.Vector3();
        clickedLayer.getWorldPosition(layerWorldPos);
        
        // è·å–ç‚¹å‡»å±‚çš„Zè½´æ–¹å‘ï¼ˆé¢å‘æ–¹å‘ï¼‰
        const zDirection = new THREE.Vector3(0, 0, 1);
        clickedLayer.localToWorld(zDirection);
        zDirection.sub(layerWorldPos).normalize();
        
        // æ²¿ç€ç‚¹å‡»å±‚é¢å‘çš„æ–¹å‘åç§»
        const offsetDistance = 0.1;
        const markerPos = layerWorldPos.clone().add(zDirection.multiplyScalar(offsetDistance));
        
        return markerPos;
    }


    function updateStartInfo() {
        const element = document.getElementById('startInfo');
        
        if (startPoint) {
            if (startPoint.isDoor) {
                // ç»Ÿä¸€æ˜¾ç¤ºä¸º"å¤§é—¨"ï¼Œä¸åŒºåˆ†å†…å¤–ä¾§
                element.textContent = 'èµ·ç‚¹: å¤§é—¨';
                element.style.borderLeftColor = '#4CAF50'; // è“è‰²è¾¹æ¡†
                element.style.color = '#2E7D32';
            } else {
                const faceText = startPoint.face === 'back' ? 'èƒŒé¢' : 'æ­£é¢';
                element.textContent = 
                    `èµ·ç‚¹: ä¹¦æ¶${startPoint.shelfIndex} ${faceText} ç¬¬${startPoint.column}åˆ—ç¬¬${startPoint.row}å±‚`;
                element.style.borderLeftColor = '#4CAF50'; // ç»¿è‰²è¾¹æ¡†
                element.style.color = '#2E7D32';
            }
        } else {
            element.textContent = 'èµ·ç‚¹: æœªè®¾ç½®';
            element.style.borderLeftColor = '';
            element.style.color = '';
        }
    }

    function updateEndInfo() {
        const element = document.getElementById('endInfo');
        
        if (endPoint) {
            if (endPoint.isDoor) {
                // ç»Ÿä¸€æ˜¾ç¤ºä¸º"å¤§é—¨"
                element.textContent = 'ç»ˆç‚¹: å¤§é—¨';
                element.style.borderLeftColor = '#F44336'; // è“è‰²è¾¹æ¡†
                element.style.color = '#C62828';
            } else {
                const faceText = endPoint.face === 'back' ? 'èƒŒé¢' : 'æ­£é¢';
                element.textContent = 
                    `ç»ˆç‚¹: ä¹¦æ¶${endPoint.shelfIndex} ${faceText} ç¬¬${endPoint.column}åˆ—ç¬¬${endPoint.row}å±‚`;
                element.style.borderLeftColor = '#F44336'; // çº¢è‰²è¾¹æ¡†
                element.style.color = '#C62828';
            }
        } else {
            element.textContent = 'ç»ˆç‚¹: æœªè®¾ç½®';
            element.style.borderLeftColor = '';
            element.style.color = '';
        }
    }


        // ========== æ˜¾ç¤ºç‚¹å‡»æç¤º ==========
        function showClickHint(message) {
            let hint = document.getElementById('clickHint');
            if (!hint) {
                hint = document.createElement('div');
                hint.id = 'clickHint';
                hint.className = 'click-hint';
                document.body.appendChild(hint);
            }
            
            hint.textContent = message;
            hint.style.display = 'block';
            
            // 3ç§’åéšè—
            setTimeout(() => {
                hint.style.display = 'none';
            }, 3000);
        }

        function showSelectionHint(layerData) {
        let message = '';
        
        if (layerData.isDoor) {
            message = `å·²é€‰æ‹©å¤§é—¨ ${layerData.faceChinese}`;
        } else {
            const faceText = layerData.face === 'back' ? 'èƒŒé¢' : 'æ­£é¢';
            message = `å·²é€‰æ‹©ä¹¦æ¶${layerData.shelfIndex} ${faceText} ç¬¬${layerData.column}åˆ—ç¬¬${layerData.row}å±‚`;
        }
        
        // ä½¿ç”¨ç°æœ‰çš„showClickHintå‡½æ•°
        showClickHint(message);
    }

        // ========== æŒ‰é’®äº‹ä»¶ç›‘å¬ ==========
        document.addEventListener('DOMContentLoaded', function() {
            const startBtn = document.getElementById('startBtn');
            const endBtn = document.getElementById('endBtn');
            const calcBtn = document.getElementById('calcBtn');

            if (startBtn) {
                startBtn.addEventListener('click', function() {
                    isSettingStart = !isSettingStart;
                    isSettingEnd = false;
                    
                    // æ›´æ–°æŒ‰é’®çŠ¶æ€
                    startBtn.classList.toggle('active');
                    endBtn.classList.remove('active');
                    
                    // æ˜¾ç¤ºæç¤º
                    if (isSettingStart) {
                        showClickHint('è¯·ç‚¹å‡»ä¹¦æ¶ä¸Šçš„æ ¼å­è®¾ç½®èµ·ç‚¹');
                    }
                });
            }
            
            if (endBtn) {
                endBtn.addEventListener('click', function() {
                    isSettingEnd = !isSettingEnd;
                    isSettingStart = false;
                    
                    // æ›´æ–°æŒ‰é’®çŠ¶æ€
                    endBtn.classList.toggle('active');
                    startBtn.classList.remove('active');
                    
                    // æ˜¾ç¤ºæç¤º
                    if (isSettingEnd) {
                        showClickHint('è¯·ç‚¹å‡»ä¹¦æ¶ä¸Šçš„æ ¼å­è®¾ç½®ç»ˆç‚¹');
                    }
                });
            }
            
            if (calcBtn) {
            calcBtn.addEventListener('click', function() {
                // æ·»åŠ æ¿€æ´»çŠ¶æ€
                calcBtn.classList.add('active');
                
                // è®¡ç®—å¹¶æ˜¾ç¤ºè·¯å¾„
                calculateAndShowPath();
                
                // 0.5ç§’åç§»é™¤æ¿€æ´»çŠ¶æ€
                setTimeout(() => {
                    calcBtn.classList.remove('active');
                }, 500);
            });
        }

            // ESCé”®å–æ¶ˆè®¾ç½®æ¨¡å¼
            document.addEventListener('keydown', function(event) {
                if (event.key === 'Escape') {
                    isSettingStart = false;
                    isSettingEnd = false;
                    startBtn.classList.remove('active');
                    endBtn.classList.remove('active');
                }
            });
        });

        camera.position.set(-13, 8, -13);
        controls.update();


        // å…¶ä»–éœ€è¦æš´éœ²çš„å‡½æ•°
        window.updateStartInfo = updateStartInfo;
        window.updateEndInfo = updateEndInfo;
        window.updatePathInfo = updatePathInfo;
        
        // åœ¨3Dæ¨¡å‹åŠ è½½å®Œæˆåï¼Œanimate()å‡½æ•°ä¹‹å‰æ·»åŠ ï¼š

        // ========== ç­‰å¾…æ‰€æœ‰3Dæ¨¡å‹åŠ è½½å®Œæˆååˆå§‹åŒ–API ==========
        let modelsLoaded = 0;
        const totalModels = 7; // æ ¹æ®å®é™…æ¨¡å‹æ•°é‡è°ƒæ•´

        function onModelLoaded() {
            modelsLoaded++;
            console.log(`æ¨¡å‹åŠ è½½è¿›åº¦: ${modelsLoaded}/${totalModels}`);
            
            if (modelsLoaded >= totalModels) {
                console.log('æ‰€æœ‰3Dæ¨¡å‹åŠ è½½å®Œæˆï¼Œåˆå§‹åŒ–API...');
                initAPI();
            }
        }

    function initAPI() {
        // å»¶è¿Ÿä¸€ç‚¹æ—¶é—´ç¡®ä¿æ‰€æœ‰å˜é‡éƒ½å·²å°±ç»ª
        setTimeout(() => {
            if (typeof LibraryNavigationAPI !== 'undefined') {
                LibraryNavigationAPI.manualInit(function(success) {
                    if (success) {
                        console.log('[API] æ‰‹åŠ¨åˆå§‹åŒ–æˆåŠŸ');
                        
                        // æ›´æ–°APIçŠ¶æ€æ˜¾ç¤º
                        const statusElement = document.getElementById('apiStatus');
                        if (statusElement) {
                            statusElement.textContent = 'APIå·²å°±ç»ªï¼Œå¯ä»¥ä½¿ç”¨';
                            statusElement.className = '';
                        }
                        
                        // è®¾ç½®APIæµ‹è¯•é¢æ¿åŠŸèƒ½
                        setupAPITestPanel();
                    } else {
                        console.error('[API] æ‰‹åŠ¨åˆå§‹åŒ–å¤±è´¥');
                        const statusElement = document.getElementById('apiStatus');
                        if (statusElement) {
                            statusElement.textContent = 'APIåˆå§‹åŒ–å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•';
                            statusElement.className = 'error';
                        }
                    }
                });
            } else {
                console.error('APIæ–‡ä»¶æœªåŠ è½½');
                const statusElement = document.getElementById('apiStatus');
                if (statusElement) {
                    statusElement.textContent = 'APIæ–‡ä»¶æœªåŠ è½½ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶è·¯å¾„';
                    statusElement.className = 'error';
                }
            }
        }, 500);
    }

        function animate() {
            requestAnimationFrame(animate);
            
            // æ›´æ–°æ‰€æœ‰æ ‡ç­¾æœå‘ç›¸æœº
            scene.traverse((object) => {
                if (object.type === 'Sprite') {
                    // ä½¿ç²¾çµå§‹ç»ˆæœå‘ç›¸æœº
                    object.lookAt(camera.position);
                }
            });
            
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        // ç›‘å¬çª—å£å¤§å°å˜åŒ–ï¼Œé€‚é…å°ç¨‹åºweb-view
        window.addEventListener('resize', function() {
            // æ›´æ–°ç›¸æœºå®½é«˜æ¯”
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            // æ›´æ–°æ¸²æŸ“å™¨å°ºå¯¸
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // åˆå§‹åŒ–æ—¶å¼ºåˆ¶è§¦å‘ä¸€æ¬¡é€‚é…
        window.dispatchEvent(new Event('resize'));

        // ========== åˆå§‹åŒ–ç½‘æ ¼ç³»ç»Ÿ ==========
        initGridMap();

            // APIæµ‹è¯•é¢æ¿åˆå§‹åŒ–ä»£ç 
            // è¿™æ®µä»£ç éœ€è¦åœ¨3Dç³»ç»Ÿåˆå§‹åŒ–å®Œæˆåæ‰§è¡Œ
            
            // è®¾ç½®APIæµ‹è¯•é¢æ¿åŠŸèƒ½
            
            
            // æ·»åŠ ç¤ºä¾‹æ•°æ®æŒ‰é’®ï¼ˆå¯é€‰åŠŸèƒ½ï¼‰
            function addExampleDataButtons() {
                const examples = [
                    {
                        name: 'ç¤ºä¾‹1: ä¹¦æ¶1â†’å¤§é—¨',
                        start: '{"isDoor": false, "shelfIndex": 1, "face": "back", "column": 2, "row": 3}',
                        end: '{"isDoor": true}'
                    },
                    {
                        name: 'ç¤ºä¾‹2: å¤§é—¨â†’ä¹¦æ¶14',
                        start: '{"isDoor": true}',
                        end: '{"isDoor": false, "shelfIndex": 14, "face": "back", "column": 2, "row": 2}'
                    },
                    {
                        name: 'ç¤ºä¾‹3: ä¹¦æ¶5â†’ä¹¦æ¶10',
                        start: '{"isDoor": false, "shelfIndex": 5, "face": "front", "column": 1, "row": 4}',
                        end: '{"isDoor": false, "shelfIndex": 10, "face": "back", "column": 3, "row": 1}'
                    }
                ];
                
                const panel = document.getElementById('apiTestPanel');
                
                examples.forEach((example, index) => {
                    const button = document.createElement('button');
                    button.textContent = example.name;
                    button.style.cssText = 'width:100%; padding:6px; margin:2px 0; background:#E3F2FD; border:1px solid #90CAF9; border-radius:4px; cursor:pointer; font-size:12px;';
                    
                    button.addEventListener('click', function() {
                        document.getElementById('startData').value = example.start;
                        document.getElementById('endData').value = example.end;
                        document.getElementById('apiStatus').textContent = 'å·²åŠ è½½ç¤ºä¾‹æ•°æ® ' + (index + 1);
                        document.getElementById('apiStatus').className = '';
                    });
                    
                    panel.appendChild(button);
                });
            }
    </script>
        <!-- åœ¨Three.jsç›¸å…³è„šæœ¬ä¹‹åå¼•å…¥ -->
    <script src="3D_navigation_api.js"></script>
</body>
</html>



